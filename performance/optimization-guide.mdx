---
title: Guía de Optimización de Rendimiento
description: 'Estrategias completas de optimización para mejorar el rendimiento de
  RetroGameCloud: caching, base de datos, Kubernetes, Kong, Docker y monitorización'
icon: gauge-high
---

# Guía de Optimización de Rendimiento

Esta guía proporciona estrategias integrales para optimizar el rendimiento de RetroGameCloud, cubriendo todos los aspectos desde el caching hasta la monitorización de métricas clave.

<Note>
Las optimizaciones deben implementarse de forma gradual y siempre midiendo el impacto antes y después de cada cambio.
</Note>

## Estrategias de Caching

### Caching en Kong Gateway

<Tabs>
  <Tab title="Configuración Básica">
    ```yaml
    plugins:
      - name: proxy-cache
        config:
          request_method: ["GET"]
          response_code: [200]
          content_type: ["application/json"]
          cache_ttl: 300  # 5 minutos
          cache_control: false
          storage_ttl: 3600
    ```

  </Tab>
  <Tab title="Por Endpoints">
    ```yaml
    # Catálogo de juegos - TTL 5 minutos
    services:
      - name: game-catalog
        plugins:
          - name: proxy-cache
            config:
              cache_ttl: 300
              vary_headers: ["Accept-Language"]

    # Rankings - TTL 2 minutos
    services:
      - name: ranking
        plugins:
          - name: proxy-cache
            config:
              cache_ttl: 120
              cache_control: true
    ```

  </Tab>
</Tabs>

### CloudFront para Assets Estáticos

```yaml

# cloudfront-config.yml
Distribution:
  DistributionConfig:
    DefaultCacheBehavior:
      TargetOriginId: S3-RetroGameAssets
      ViewerProtocolPolicy: redirect-to-https
      CachePolicyId: 4135ea2d-6df8-44a3-9df3-4b5a84be39ad  # Managed-CachingOptimized
      TTL:
        DefaultTTL: 86400   # 1 día
        MaxTTL: 31536000    # 1 año
    CacheBehaviors:
      - PathPattern: "*.rom"
        TTL:
          DefaultTTL: 604800  # 1 semana
      - PathPattern: "*.png"
        TTL:
          DefaultTTL: 86400   # 1 día

```

## Optimización de Base de Datos

### Índices Recomendados

<Card title="Índices Críticos" icon="database">

```sql

- - Servicio de Scores
CREATE INDEX CONCURRENTLY idx_scores_game_score
ON scores(game_id, score DESC);

CREATE INDEX CONCURRENTLY idx_scores_user_game
ON scores(user_id, game_id);

- - Servicio de Game Catalog
CREATE INDEX CONCURRENTLY idx_games_slug
ON games(slug);

CREATE INDEX CONCURRENTLY idx_games_category_created
ON games(category, created_at DESC);

- - Servicio de User
CREATE INDEX CONCURRENTLY idx_users_email_active
ON users(email) WHERE active = true;

```

</Card>

### Connection Pooling

```javascript
// config/database.js
const pool = new Pool({
  user: process.env.DB_USER,
  host: process.env.DB_HOST,
  database: process.env.DB_NAME,
  password: process.env.DB_PASSWORD,
  port: 5432,

  // Configuración del pool
  max: 20,              // Máximo de conexiones
  min: 5,               // Mínimo de conexiones
  idleTimeoutMillis: 30000,
  connectionTimeoutMillis: 2000,

  // Configuración de performance
  statement_timeout: 5000,
  query_timeout: 5000,
  application_name: 'retrogame-service'
});

```

## Configuración de Kubernetes

### Límites de Recursos por Servicio

<Tabs>
  <Tab title="Auth Service">
    ```yaml
    apiVersion: apps/v1
    kind: Deployment
    metadata:
      name: auth-service
    spec:
      template:
        spec:
          containers:
          - name: auth-service
            resources:
              requests:
                memory: "128Mi"
                cpu: "100m"
              limits:
                memory: "256Mi"
                cpu: "300m"
            readinessProbe:
              httpGet:
                path: /health
                port: 3000
              initialDelaySeconds: 10
              periodSeconds: 5
    ```

  </Tab>
  <Tab title="Game Catalog">
    ```yaml
    apiVersion: apps/v1
    kind: Deployment
    metadata:
      name: game-catalog-service
    spec:
      template:
        spec:
          containers:
          - name: game-catalog
            resources:
              requests:
                memory: "256Mi"
                cpu: "200m"
              limits:
                memory: "512Mi"
                cpu: "500m"
            env:
            - name: NODE_OPTIONS
              value: "--max-old-space-size=400"
    ```

  </Tab>
  <Tab title="User Service">
    ```yaml
    apiVersion: apps/v1
    kind: Deployment
    metadata:
      name: user-service
    spec:
      template:
        spec:
          containers:
          - name: user-service
            resources:
              requests:
                memory: "128Mi"
                cpu: "100m"
              limits:
                memory: "256Mi"
                cpu: "300m"
    ```

  </Tab>
  <Tab title="Score & Ranking">
    ```yaml
    apiVersion: apps/v1
    kind: Deployment
    metadata:
      name: score-service
    spec:
      template:
        spec:
          containers:
          - name: score-service
            resources:
              requests:
                memory: "256Mi"
                cpu: "150m"
              limits:
                memory: "1Gi"
                cpu: "500m"
            # Configuración para picos de escritura
            env:
            - name: MAX_CONCURRENT_REQUESTS
              value: "100"
    ```

  </Tab>
</Tabs>

### Horizontal Pod Autoscaler (HPA)

```yaml
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: game-catalog-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: game-catalog-service
  minReplicas: 2
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80

```

## Optimización de Kong Gateway

### Configuración Avanzada

```yaml

# kong.yml
_format_version: "2.1"

services:
  - name: retrogame-api
    url: http://kong-upstream
    plugins:
      - name: rate-limiting
        config:
          minute: 100
          hour: 1000

      - name: response-transformer
        config:
          add:
            headers:
              - "Cache-Control: public, max-age=300"

      - name: gzip
        config:
          types:
            - "application/json"
            - "text/html"
            - "text/css"
            - "application/javascript"

upstreams:
  - name: kong-upstream
    algorithm: round-robin
    healthchecks:
      active:
        http_path: "/health"
        healthy:
          interval: 5
          successes: 3
        unhealthy:
          interval: 5
          http_failures: 3

```

<Warning>
La compresión gzip puede aumentar el uso de CPU. Monitoriza el impacto en el rendimiento del gateway.
</Warning>

## Optimización de Imágenes Docker

### Imágenes Multi-stage con Alpine

```dockerfile

# Dockerfile optimizado

# Etapa de construcción
FROM node:18-alpine AS builder

WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production && npm cache clean --force

# Etapa de producción
FROM node:18-alpine AS production

# Crear usuario no-root
RUN addgroup -g 1001 -S nodejs && \
    adduser -S nextjs -u 1001

# Optimizaciones del sistema
RUN apk add --no-cache dumb-init && \
    rm -rf /var/cache/apk/*

WORKDIR /app

# Copiar dependencias desde builder
COPY --from=builder --chown=nextjs:nodejs /app/node_modules ./node_modules
COPY --chown=nextjs:nodejs . .

USER nextjs

# Configurar Node.js para producción
ENV NODE_ENV=production
ENV NODE_OPTIONS="--max-old-space-size=256"

EXPOSE 3000

ENTRYPOINT ["dumb-init", "--"]
CMD ["node", "server.js"]

```

### Mejores Prácticas Docker

<Card title="Optimizaciones Adicionales" icon="docker">

- **Usar .dockerignore**: Excluir archivos innecesarios

- **Layers eficientes**: Ordenar comandos del menos al más cambiante

- **Limpiar caches**: Eliminar archivos temporales en la misma capa

- **Imágenes base mínimas**: Preferir Alpine o Distroless

- **Escaneo de seguridad**: Usar herramientas como Snyk o Trivy
</Card>

## Métricas de Rendimiento

### Métricas Clave a Monitorizar

```yaml

# prometheus-rules.yml
groups:
  - name: retrogame-performance
    rules:
      - alert: HighLatency
        expr: histogram_quantile(0.95, http_request_duration_seconds_bucket) > 0.2
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "Latencia P95 alta detectada"
          description: "La latencia P95 es {{ $value }}s, superior al umbral de 200ms"

      - alert: HighErrorRate
        expr: rate(http_requests_total{status=~"5.."}[5m]) / rate(http_requests_total[5m]) > 0.01
        for: 2m
        labels:
          severity: critical
        annotations:
          summary: "Tasa de error alta"
          description: "Tasa de error del {{ $value | humanizePercentage }} en los últimos 5 minutos"

      - alert: DatabaseConnectionsHigh
        expr: pg_stat_database_numbackends / pg_settings_max_connections > 0.8
        for: 3m
        labels:
          severity: warning
        annotations:
          summary: "Alto uso de conexiones de BD"

```

### Dashboard de Grafana

```json
{
  "dashboard": {
    "title": "RetroGameCloud Performance",
    "panels": [
      {
        "title": "Latencia de Respuesta (P95)",
        "type": "stat",
        "targets": [
          {
            "expr": "histogram_quantile(0.95, rate(http_request_duration_seconds_bucket[5m]))",
            "legendFormat": "P95 Latency"
          }
        ],
        "fieldConfig": {
          "defaults": {
            "unit": "s",
            "max": 0.5,
            "thresholds": {
              "steps": [
                {"color": "green", "value": null},
                {"color": "yellow", "value": 0.2},
                {"color": "red", "value": 0.5}
              ]
            }
          }
        }
      }
    ]
  }
}

```

## Objetivos de Rendimiento

### SLAs Recomendados

<Tabs>
  <Tab title="Latencia">
    - **P50 < 100ms**: Para el 50% de las peticiones
    - **P95 < 200ms**: Para el 95% de las peticiones
    - **P99 < 500ms**: Para el 99% de las peticiones
  </Tab>
  <Tab title="Disponibilidad">
    - **Uptime > 99.9%**: Objetivo de disponibilidad
    - **MTTR < 15 min**: Tiempo medio de recuperación
    - **RPO < 5 min**: Punto de recuperación objetivo
  </Tab>
  <Tab title="Throughput">
    - **> 1000 RPS**: Peticiones por segundo pico
    - **Error rate < 1%**: Tasa de error máxima
    - **Concurrent users > 5000**: Usuarios concurrentes
  </Tab>
</Tabs>

## Monitorización Continua

### Métricas de Aplicación

```javascript
// metrics.js - Instrumentación con Prometheus
const promClient = require('prom-client');

// Métricas personalizadas
const httpRequestDuration = new promClient.Histogram({
  name: 'http_request_duration_seconds',
  help: 'Duration of HTTP requests in seconds',
  labelNames: ['method', 'route', 'status_code'],
  buckets: [0.01, 0.05, 0.1, 0.2, 0.5, 1, 2, 5]
});

const gameLoadTime = new promClient.Histogram({
  name: 'game_load_time_seconds',
  help: 'Time taken to load game ROM',
  labelNames: ['game_slug'],
  buckets: [0.5, 1, 2, 5, 10, 30]
});

const activeGames = new promClient.Gauge({
  name: 'active_games_total',
  help: 'Number of currently active game sessions'
});

// Middleware de métricas
const metricsMiddleware = (req, res, next) => {
  const start = Date.now();

  res.on('finish', () => {
    const duration = (Date.now() - start) / 1000;
    httpRequestDuration
      .labels(req.method, req.route?.path || req.url, res.statusCode)
      .observe(duration);
  });

  next();
};

module.exports = { httpRequestDuration, gameLoadTime, activeGames, metricsMiddleware };

```

<Note>
Recuerda revisar estas métricas semanalmente y ajustar los umbrales según el comportamiento real de la aplicación en producción.
</Note>

Esta guía proporciona una base sólida para optimizar el rendimiento de RetroGameCloud. Implementa las mejoras de forma incremental y siempre valida el impacto con métricas concretas.