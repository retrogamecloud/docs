---
title: "1.1.2. Desarrollo Local"
description: "Ejecuta RetroGame Cloud en tu m√°quina local paso a paso"
icon: "laptop-code"
---

## Introducci√≥n

Esta gu√≠a te lleva desde ejecutar un microservicio b√°sico en Node.js hasta un cluster completo de Kubernetes. Progresar√°s a trav√©s de 4 niveles:

<Steps>
  <Step title="Nivel 1: Node.js Puro">
    Ejecutar servicios directamente con Node.js
  </Step>
  <Step title="Nivel 2: Docker">
    Containerizar servicios individuales
  </Step>
  <Step title="Nivel 3: Docker Compose">
    Orquestar todos los servicios localmente
  </Step>
  <Step title="Nivel 4: Minikube">
    Desplegar en Kubernetes local
  </Step>
</Steps>

---

## Nivel 1: Node.js Puro

### Requisitos

```bash
node --version  # v18 o superior
npm --version   # v9 o superior
```

### Ejecutar el Servicio de Autenticaci√≥n

<Steps>
  <Step title="Clonar y configurar">
    ```bash
    git clone https://github.com/retrogamecloud/infrastructure.git
    cd infrastructure
    
    # Instalar dependencias del auth-service
    cd auth-service
    npm install
    ```
  </Step>
  
  <Step title="Configurar variables de entorno">
    Crea un archivo `.env`:
    ```bash
    # Base de datos (usar SQLite para testing local)
    DB_HOST=localhost
    DB_PORT=5432
    DB_NAME=retrogame_dev
    DB_USER=postgres
    DB_PASSWORD=postgres
    
    # JWT
    JWT_SECRET=mi-secreto-super-seguro-cambiar-en-produccion
    JWT_EXPIRATION=24h
    
    # Puerto del servicio
    PORT=3001
    ```
  </Step>
  
  <Step title="Iniciar PostgreSQL local (opcional)">
    Si tienes PostgreSQL instalado:
    ```bash
    # Crear base de datos
    createdb retrogame_dev
    
    # Ejecutar migraciones
    npm run migrate
    ```
    
    O usa SQLite para desarrollo r√°pido:
    ```javascript
    // En config/database.js
    module.exports = {
      development: {
        dialect: 'sqlite',
        storage: './dev.sqlite'
      }
    }
    ```
  </Step>
  
  <Step title="Ejecutar el servicio">
    ```bash
    npm run dev
    ```
    
    Ver√°s:
    ```
    üöÄ Auth Service running on http://localhost:3001
    ‚úÖ Database connected
    ```
  </Step>
</Steps>

### Probar el Servicio

```bash
# Registrar usuario
curl -X POST http://localhost:3001/auth/register \
  -H "Content-Type: application/json" \
  -d '{
    "username": "player1",
    "email": "player1@test.com",
    "password": "password123"
  }'

# Login
curl -X POST http://localhost:3001/auth/login \
  -H "Content-Type: application/json" \
  -d '{
    "email": "player1@test.com",
    "password": "password123"
  }'
```

### Ejecutar Todos los Servicios

<Accordion title="Servicios disponibles y sus puertos">
  - **Auth Service**: Puerto 3001
  - **Game Catalog Service**: Puerto 3002
  - **Score Service**: Puerto 3003
  - **Ranking Service**: Puerto 3004 (requiere Redis)
  - **User Service**: Puerto 3005
  - **Frontend**: Puerto 8080
</Accordion>

```bash
# Terminal 1: Auth Service
cd auth-service && npm run dev

# Terminal 2: Game Catalog Service
cd game-catalog-service && npm install && npm run dev

# Terminal 3: Score Service
cd score-service && npm install && npm run dev

# Terminal 4: Ranking Service (necesita Redis)
redis-server --port 6379 &
cd ranking-service && npm install && npm run dev

# Terminal 5: User Service
cd user-service && npm install && npm run dev

# Terminal 6: Frontend
cd frontend && npm install && npm start
```

<Warning>
  Ejecutar m√∫ltiples terminales es tedioso - por eso usamos Docker üëá
</Warning>

---

## Nivel 2: Docker

### Requisitos

```bash
docker --version  # Docker 20.10+
```

### Buildear Imagen de un Servicio

<Steps>
  <Step title="Revisar el Dockerfile">
    ```dockerfile
    # auth-service/Dockerfile
    FROM node:18-alpine
    
    WORKDIR /app
    
    # Instalar dependencias
    COPY package*.json ./
    RUN npm ci --only=production
    
    # Copiar c√≥digo
    COPY . .
    
    EXPOSE 3001
    
    CMD ["node", "src/index.js"]
    ```
  </Step>
  
  <Step title="Construir la imagen">
    ```bash
    cd auth-service
    docker build -t retrogame/auth-service:latest .
    ```
    
    Ver√°s:
    ```
    [+] Building 45.3s (10/10) FINISHED
    => [1/5] FROM node:18-alpine
    => [2/5] WORKDIR /app
    => [3/5] COPY package*.json ./
    => [4/5] RUN npm ci --only=production
    => [5/5] COPY . .
    => exporting to image
    => => naming to docker.io/retrogame/auth-service:latest
    ```
  </Step>
  
  <Step title="Ejecutar el contenedor">
    ```bash
    docker run -d \
      --name auth-service \
      -p 3001:3001 \
      -e DB_HOST=host.docker.internal \
      -e DB_PASSWORD=postgres \
      -e JWT_SECRET=mi-secreto \
      retrogame/auth-service:latest
    ```
  </Step>
  
  <Step title="Ver logs">
    ```bash
    # Logs en tiempo real
    docker logs -f auth-service
    
    # √öltimas 50 l√≠neas
    docker logs --tail 50 auth-service
    ```
  </Step>
</Steps>

### Buildear Todas las Im√°genes

```bash
# Script para buildear todos los servicios
#!/bin/bash

services=(
  "auth-service"
  "game-catalog-service"
  "score-service"
  "ranking-service"
  "user-service"
  "frontend"
)

for service in "${services[@]}"; do
  echo "üèóÔ∏è  Building $service..."
  cd $service
  docker build -t retrogame/$service:latest .
  cd ..
done

echo "‚úÖ All images built!"
```

### Gestionar Contenedores

```bash
# Ver contenedores corriendo
docker ps

# Detener contenedor
docker stop auth-service

# Eliminar contenedor
docker rm auth-service

# Ver logs
docker logs auth-service

# Acceder al contenedor
docker exec -it auth-service sh

# Ver uso de recursos
docker stats
```

<Tip>
  Docker resuelve el problema de "funciona en mi m√°quina" - pero gestionar 6+ contenedores manualmente es complejo. Siguiente nivel: Docker Compose üëá
</Tip>

---

## Nivel 3: Docker Compose

Docker Compose orquesta m√∫ltiples contenedores con un solo comando.

### Archivo docker-compose.yml

<CodeGroup>
```yaml docker-compose.yml
version: '3.8'

services:
  # Base de datos PostgreSQL
  postgres:
    image: postgres:15-alpine
    container_name: retrogame-postgres
    environment:
      POSTGRES_DB: retrogamedb
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./scripts/init-db.sql:/docker-entrypoint-initdb.d/init.sql
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 10s
      timeout: 5s
      retries: 5

  # Redis para cach√© de rankings
  redis:
    image: redis:7-alpine
    container_name: retrogame-redis
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 3s
      retries: 5

  # Servicio de Autenticaci√≥n
  auth-service:
    build: ./auth-service
    container_name: auth-service
    ports:
      - "3001:3001"
    environment:
      DB_HOST: postgres
      DB_PORT: 5432
      DB_NAME: retrogamedb
      DB_USER: postgres
      DB_PASSWORD: postgres
      JWT_SECRET: dev-secret-cambiar-en-produccion
      JWT_EXPIRATION: 24h
      PORT: 3001
    depends_on:
      postgres:
        condition: service_healthy
    restart: unless-stopped

  # Servicio de Cat√°logo de Juegos
  game-catalog-service:
    build: ./game-catalog-service
    container_name: game-catalog-service
    ports:
      - "3002:3002"
    environment:
      DB_HOST: postgres
      DB_PORT: 5432
      DB_NAME: retrogamedb
      DB_USER: postgres
      DB_PASSWORD: postgres
      PORT: 3002
    depends_on:
      postgres:
        condition: service_healthy
    restart: unless-stopped

  # Servicio de Puntuaciones
  score-service:
    build: ./score-service
    container_name: score-service
    ports:
      - "3003:3003"
    environment:
      DB_HOST: postgres
      DB_PORT: 5432
      DB_NAME: retrogamedb
      DB_USER: postgres
      DB_PASSWORD: postgres
      REDIS_HOST: redis
      REDIS_PORT: 6379
      PORT: 3003
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    restart: unless-stopped

  # Servicio de Rankings
  ranking-service:
    build: ./ranking-service
    container_name: ranking-service
    ports:
      - "3004:3004"
    environment:
      DB_HOST: postgres
      DB_PORT: 5432
      DB_NAME: retrogamedb
      DB_USER: postgres
      DB_PASSWORD: postgres
      REDIS_HOST: redis
      REDIS_PORT: 6379
      CACHE_TTL: 300
      PORT: 3004
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    restart: unless-stopped

  # Servicio de Usuarios
  user-service:
    build: ./user-service
    container_name: user-service
    ports:
      - "3005:3005"
    environment:
      DB_HOST: postgres
      DB_PORT: 5432
      DB_NAME: retrogamedb
      DB_USER: postgres
      DB_PASSWORD: postgres
      PORT: 3005
    depends_on:
      postgres:
        condition: service_healthy
    restart: unless-stopped

  # Frontend
  frontend:
    build: ./frontend
    container_name: frontend
    ports:
      - "8080:80"
    environment:
      API_BASE_URL: http://kong:8000
    depends_on:
      - kong
    restart: unless-stopped

  # Kong API Gateway
  kong:
    image: kong:3.4-alpine
    container_name: kong
    environment:
      KONG_DATABASE: "off"
      KONG_DECLARATIVE_CONFIG: /kong/kong.yml
      KONG_PROXY_ACCESS_LOG: /dev/stdout
      KONG_ADMIN_ACCESS_LOG: /dev/stdout
      KONG_PROXY_ERROR_LOG: /dev/stderr
      KONG_ADMIN_ERROR_LOG: /dev/stderr
      KONG_ADMIN_LISTEN: 0.0.0.0:8001
    ports:
      - "8000:8000"  # Proxy
      - "8001:8001"  # Admin API
    volumes:
      - ./kong/kong.yml:/kong/kong.yml:ro
    depends_on:
      - auth-service
      - game-catalog-service
      - score-service
      - ranking-service
      - user-service
    restart: unless-stopped

volumes:
  postgres_data:
  redis_data:
```

```sql scripts/init-db.sql
-- Crear esquemas
CREATE SCHEMA IF NOT EXISTS auth;
CREATE SCHEMA IF NOT EXISTS games;
CREATE SCHEMA IF NOT EXISTS scores;
CREATE SCHEMA IF NOT EXISTS users;

-- Tabla de usuarios
CREATE TABLE IF NOT EXISTS users.users (
    id SERIAL PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Tabla de juegos
CREATE TABLE IF NOT EXISTS games.games (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    description TEXT,
    file_path VARCHAR(255) NOT NULL,
    thumbnail VARCHAR(255),
    year INTEGER,
    genre VARCHAR(50),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Tabla de puntuaciones
CREATE TABLE IF NOT EXISTS scores.scores (
    id SERIAL PRIMARY KEY,
    user_id INTEGER REFERENCES users.users(id),
    game_id INTEGER REFERENCES games.games(id),
    score INTEGER NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- √çndices para rendimiento
CREATE INDEX idx_scores_user_id ON scores.scores(user_id);
CREATE INDEX idx_scores_game_id ON scores.scores(game_id);
CREATE INDEX idx_scores_score ON scores.scores(score DESC);

-- Datos de ejemplo
INSERT INTO games.games (name, description, file_path, year, genre) VALUES
('DOOM', 'Legendary FPS game', 'doom.jsdos', 1993, 'FPS'),
('Prince of Persia', 'Classic platformer', 'prince.jsdos', 1989, 'Platform'),
('Wolfenstein 3D', 'The grandfather of FPS', 'wolf.jsdos', 1992, 'FPS');
```
</CodeGroup>

### Ejecutar con Docker Compose

<Steps>
  <Step title="Levantar todos los servicios">
    ```bash
    # Construir im√°genes y levantar servicios
    docker-compose up --build
    
    # En modo detached (background)
    docker-compose up -d
    ```
    
    Ver√°s:
    ```
    ‚úÖ Network retrogame_default created
    ‚úÖ Volume postgres_data created
    ‚úÖ Volume redis_data created
    üêò postgres started
    üî¥ redis started
    üîê auth-service started
    üéÆ game-catalog-service started
    üèÜ score-service started
    üìä ranking-service started
    üë§ user-service started
    ü¶ç kong started
    üåê frontend started
    ```
  </Step>
  
  <Step title="Verificar que todo funciona">
    ```bash
    # Ver servicios corriendo
    docker-compose ps
    
    # Ver logs de todos los servicios
    docker-compose logs -f
    
    # Ver logs de un servicio espec√≠fico
    docker-compose logs -f auth-service
    ```
  </Step>
  
  <Step title="Probar la aplicaci√≥n">
    ```bash
    # Frontend
    open http://localhost:8080
    
    # API Gateway
    curl http://localhost:8000/health
    
    # Autenticaci√≥n
    curl -X POST http://localhost:8000/auth/register \
      -H "Content-Type: application/json" \
      -d '{"username":"test","email":"test@test.com","password":"pass123"}'
    ```
  </Step>
</Steps>

### Comandos √ötiles

```bash
# Detener todos los servicios
docker-compose down

# Detener y eliminar vol√∫menes (CUIDADO: borra datos)
docker-compose down -v

# Reconstruir un servicio espec√≠fico
docker-compose up -d --build auth-service

# Escalar servicios
docker-compose up -d --scale score-service=3

# Ver logs en tiempo real
docker-compose logs -f --tail=100

# Ejecutar comando en un contenedor
docker-compose exec postgres psql -U postgres retrogamedb

# Reiniciar servicio
docker-compose restart auth-service

# Ver uso de recursos
docker stats $(docker-compose ps -q)
```

<Tip>
  Docker Compose es perfecto para desarrollo local - pero para producci√≥n necesitamos orquestaci√≥n real. Siguiente nivel: Kubernetes üëá
</Tip>

---

## Nivel 4: Minikube (Kubernetes Local)

Minikube crea un cluster de Kubernetes en tu m√°quina para probar despliegues.

### Instalar Minikube

<Tabs>
  <Tab title="Linux">
    ```bash
    curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64
    sudo install minikube-linux-amd64 /usr/local/bin/minikube
    ```
  </Tab>
  
  <Tab title="macOS">
    ```bash
    brew install minikube
    ```
  </Tab>
  
  <Tab title="Windows">
    ```powershell
    choco install minikube
    ```
  </Tab>
</Tabs>

### Iniciar Cluster

<Steps>
  <Step title="Iniciar Minikube">
    ```bash
    # Iniciar con suficientes recursos
    minikube start --cpus=4 --memory=8192 --driver=docker
    
    # Habilitar addons √∫tiles
    minikube addons enable ingress
    minikube addons enable metrics-server
    minikube addons enable dashboard
    ```
  </Step>
  
  <Step title="Configurar kubectl">
    ```bash
    # Verificar conexi√≥n
    kubectl cluster-info
    
    # Ver nodos
    kubectl get nodes
    
    # Deber√≠as ver:
    # NAME       STATUS   ROLES           AGE   VERSION
    # minikube   Ready    control-plane   1m    v1.28.3
    ```
  </Step>
  
  <Step title="Usar registro de im√°genes local">
    ```bash
    # Apuntar Docker al daemon de Minikube
    eval $(minikube docker-env)
    
    # Ahora buildea las im√°genes
    docker build -t retrogame/auth-service:latest ./auth-service
    docker build -t retrogame/game-catalog-service:latest ./game-catalog-service
    # ... resto de servicios
    ```
  </Step>
</Steps>

### Desplegar en Minikube

<CodeGroup>
```yaml kubernetes/namespace.yaml
apiVersion: v1
kind: Namespace
metadata:
  name: retrogame
```

```yaml kubernetes/postgres.yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: postgres-pvc
  namespace: retrogame
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 5Gi
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: postgres
  namespace: retrogame
spec:
  replicas: 1
  selector:
    matchLabels:
      app: postgres
  template:
    metadata:
      labels:
        app: postgres
    spec:
      containers:
      - name: postgres
        image: postgres:15-alpine
        ports:
        - containerPort: 5432
        env:
        - name: POSTGRES_DB
          value: "retrogamedb"
        - name: POSTGRES_USER
          value: "postgres"
        - name: POSTGRES_PASSWORD
          value: "postgres"
        volumeMounts:
        - name: postgres-storage
          mountPath: /var/lib/postgresql/data
      volumes:
      - name: postgres-storage
        persistentVolumeClaim:
          claimName: postgres-pvc
---
apiVersion: v1
kind: Service
metadata:
  name: postgres
  namespace: retrogame
spec:
  selector:
    app: postgres
  ports:
  - port: 5432
    targetPort: 5432
  type: ClusterIP
```

```yaml kubernetes/auth-service.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: auth-service
  namespace: retrogame
spec:
  replicas: 2
  selector:
    matchLabels:
      app: auth-service
  template:
    metadata:
      labels:
        app: auth-service
    spec:
      containers:
      - name: auth-service
        image: retrogame/auth-service:latest
        imagePullPolicy: Never  # Usar imagen local
        ports:
        - containerPort: 3001
        env:
        - name: DB_HOST
          value: "postgres"
        - name: DB_PORT
          value: "5432"
        - name: DB_NAME
          value: "retrogamedb"
        - name: DB_USER
          value: "postgres"
        - name: DB_PASSWORD
          value: "postgres"
        - name: JWT_SECRET
          value: "minikube-secret"
        - name: PORT
          value: "3001"
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "256Mi"
            cpu: "200m"
        livenessProbe:
          httpGet:
            path: /health
            port: 3001
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health
            port: 3001
          initialDelaySeconds: 5
          periodSeconds: 5
---
apiVersion: v1
kind: Service
metadata:
  name: auth-service
  namespace: retrogame
spec:
  selector:
    app: auth-service
  ports:
  - port: 3001
    targetPort: 3001
  type: ClusterIP
```
</CodeGroup>

### Aplicar Configuraci√≥n

```bash
# Crear namespace
kubectl apply -f kubernetes/namespace.yaml

# Desplegar base de datos
kubectl apply -f kubernetes/postgres.yaml
kubectl apply -f kubernetes/redis.yaml

# Esperar a que la DB est√© lista
kubectl wait --for=condition=ready pod -l app=postgres -n retrogame --timeout=60s

# Desplegar servicios
kubectl apply -f kubernetes/auth-service.yaml
kubectl apply -f kubernetes/game-catalog-service.yaml
kubectl apply -f kubernetes/score-service.yaml
kubectl apply -f kubernetes/ranking-service.yaml
kubectl apply -f kubernetes/user-service.yaml

# Desplegar frontend y Kong
kubectl apply -f kubernetes/kong.yaml
kubectl apply -f kubernetes/frontend.yaml
```

### Verificar Despliegue

```bash
# Ver todos los pods
kubectl get pods -n retrogame

# Ver servicios
kubectl get svc -n retrogame

# Ver logs de un pod
kubectl logs -f deployment/auth-service -n retrogame

# Describir pod para debugging
kubectl describe pod <pod-name> -n retrogame

# Port forward para probar
kubectl port-forward svc/auth-service 3001:3001 -n retrogame
```

### Acceder a la Aplicaci√≥n

```bash
# Obtener IP de Minikube
minikube ip

# Port forward al frontend
kubectl port-forward svc/frontend 8080:80 -n retrogame

# Abrir en navegador
open http://localhost:8080

# O usar minikube service
minikube service frontend -n retrogame
```

### Dashboard de Kubernetes

```bash
# Abrir dashboard
minikube dashboard

# Ver m√©tricas
kubectl top nodes
kubectl top pods -n retrogame
```

### Limpiar

```bash
# Eliminar todo el namespace
kubectl delete namespace retrogame

# Detener Minikube
minikube stop

# Eliminar cluster
minikube delete
```

---

## Comparaci√≥n de Niveles

<Table>
  <thead>
    <tr>
      <th>Aspecto</th>
      <th>Node.js</th>
      <th>Docker</th>
      <th>Docker Compose</th>
      <th>Minikube</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>**Complejidad**</td>
      <td>‚≠ê</td>
      <td>‚≠ê‚≠ê</td>
      <td>‚≠ê‚≠ê‚≠ê</td>
      <td>‚≠ê‚≠ê‚≠ê‚≠ê</td>
    </tr>
    <tr>
      <td>**Setup**</td>
      <td>5 min</td>
      <td>10 min</td>
      <td>15 min</td>
      <td>30 min</td>
    </tr>
    <tr>
      <td>**Portabilidad**</td>
      <td>‚ùå Baja</td>
      <td>‚úÖ Media</td>
      <td>‚úÖ Alta</td>
      <td>‚úÖ‚úÖ Muy Alta</td>
    </tr>
    <tr>
      <td>**Escalabilidad**</td>
      <td>‚ùå Manual</td>
      <td>‚ùå Manual</td>
      <td>‚ö†Ô∏è Limitada</td>
      <td>‚úÖ Autom√°tica</td>
    </tr>
    <tr>
      <td>**Monitoreo**</td>
      <td>‚ùå No</td>
      <td>‚ö†Ô∏è B√°sico</td>
      <td>‚ö†Ô∏è B√°sico</td>
      <td>‚úÖ Completo</td>
    </tr>
    <tr>
      <td>**Uso Recomendado**</td>
      <td>Desarrollo r√°pido</td>
      <td>Testing individual</td>
      <td>Desarrollo completo</td>
      <td>Testing pre-producci√≥n</td>
    </tr>
  </tbody>
</Table>

## Pr√≥ximos Pasos

<CardGroup cols={2}>
  <Card title="Desplegar en AWS EKS" icon="aws" href="/quickstart">
    Lleva tu aplicaci√≥n a producci√≥n
  </Card>
  <Card title="Configurar CI/CD" icon="github">
    Automatiza deployments con GitHub Actions
  </Card>
  <Card title="Monitoreo Avanzado" icon="chart-line" href="/infrastructure/monitoring">
    Prometheus, Grafana y alertas
  </Card>
  <Card title="Arquitectura" icon="sitemap" href="/architecture">
    Entiende el dise√±o completo
  </Card>
</CardGroup>
