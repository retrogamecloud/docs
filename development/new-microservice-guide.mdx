---
title: Guía de Desarrollo de Nuevos Microservicios
description: Tutorial completo para agregar un nuevo microservicio al ecosistema RetroGameCloud
  siguiendo los patrones establecidos
icon: microchip
---

# Guía de desarrollo de nuevos microservicios

Esta guía te llevará paso a paso por el proceso de creación e integración de un nuevo microservicio en RetroGameCloud, asegurando la consistencia con los patrones arquitectónicos establecidos.

## Prerrequisitos

<Note>
Antes de comenzar, asegúrate de tener acceso a:

- Repositorio del proyecto en GitHub

- Cluster de AWS EKS

- Kong Gateway configurado

- ArgoCD instalado

- Variables de entorno del proyecto
</Note>

## 1. Estructura del proyecto

### Template de carpetas

Crea la siguiente estructura base para tu nuevo microservicio:

```

my-new-service/
├── src/
│   ├── controllers/
│   │   ├── index.js
│   │   └── healthController.js
│   ├── routes/
│   │   ├── index.js
│   │   └── api.js
│   ├── models/
│   │   └── index.js
│   ├── middlewares/
│   │   ├── auth.js
│   │   ├── validation.js
│   │   └── errorHandler.js
│   ├── config/
│   │   ├── database.js
│   │   ├── kong.js
│   │   └── env.js
│   ├── utils/
│   │   └── logger.js
│   └── app.js
├── tests/
│   ├── unit/
│   └── integration/
├── k8s/
│   ├── deployment.yaml
│   ├── service.yaml
│   ├── configmap.yaml
│   └── secrets.yaml
├── .github/
│   └── workflows/
│       └── ci-cd.yml
├── Dockerfile
├── package.json
├── .dockerignore
├── .gitignore
└── README.md

```

### Configuración base del servicio

<Tabs>
<Tab title="app.js">

```javascript
const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const compression = require('compression');
const rateLimit = require('express-rate-limit');
const { errorHandler } = require('./middlewares/errorHandler');
const routes = require('./routes');
const config = require('./config/env');
const logger = require('./utils/logger');

const app = express();

// Middlewares de seguridad
app.use(helmet());
app.use(cors({
  origin: process.env.ALLOWED_ORIGINS?.split(',') || '*',
  credentials: true
}));

// Rate limiting
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutos
  max: 100 // límite de requests por ventana
});
app.use(limiter);

// Middlewares generales
app.use(compression());
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true }));

// Health checks obligatorios
app.get('/health', (req, res) => {
  res.status(200).json({
    status: 'UP',
    timestamp: new Date().toISOString(),
    service: process.env.SERVICE_NAME || 'my-new-service',
    version: process.env.SERVICE_VERSION || '1.0.0'
  });
});

// Métricas para Prometheus
app.get('/metrics', (req, res) => {
  // Implementar métricas específicas del servicio
  res.status(200).json({
    uptime: process.uptime(),
    memory: process.memoryUsage(),
    timestamp: Date.now()
  });
});

// Rutas principales
app.use('/api/v1', routes);

// Manejo de errores
app.use(errorHandler);

const PORT = process.env.PORT || 3000;

app.listen(PORT, () => {
  logger.info(`${config.serviceName} iniciado en puerto ${PORT}`);
});

module.exports = app;

```

</Tab>

<Tab title="config/env.js">

```javascript
require('dotenv').config();

module.exports = {
  serviceName: process.env.SERVICE_NAME || 'my-new-service',
  port: process.env.PORT || 3000,
  nodeEnv: process.env.NODE_ENV || 'development',

  // Base de datos
  database: {
    host: process.env.DB_HOST || 'localhost',
    port: process.env.DB_PORT || 5432,
    name: process.env.DB_NAME,
    user: process.env.DB_USER,
    password: process.env.DB_PASSWORD,
    ssl: process.env.DB_SSL === 'true'
  },

  // Kong Gateway
  kong: {
    adminUrl: process.env.KONG_ADMIN_URL || 'http://kong-admin:8001',
    gatewayUrl: process.env.KONG_GATEWAY_URL || 'http://kong:8000'
  },

  // JWT
  jwt: {
    secret: process.env.JWT_SECRET,
    expiresIn: process.env.JWT_EXPIRES_IN || '24h'
  },

  // Otros servicios
  services: {
    auth: process.env.AUTH_SERVICE_URL || 'http://auth-service:3000',
    user: process.env.USER_SERVICE_URL || 'http://user-service:3000'
  }
};

```

</Tab>

<Tab title="utils/logger.js">

```javascript
const winston = require('winston');

const logger = winston.createLogger({
  level: process.env.LOG_LEVEL || 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.json()
  ),
  defaultMeta: {
    service: process.env.SERVICE_NAME || 'my-new-service',
    version: process.env.SERVICE_VERSION || '1.0.0'
  },
  transports: [
    new winston.transports.File({ filename: 'error.log', level: 'error' }),
    new winston.transports.File({ filename: 'combined.log' })
  ]
});

if (process.env.NODE_ENV !== 'production') {
  logger.add(new winston.transports.Console({
    format: winston.format.simple()
  }));
}

module.exports = logger;

```

</Tab>

```

</Tab>
</Tabs>

## 2. Dockerfile multi-stage

Utiliza este template siguiendo el patrón establecido:

```dockerfile

# Stage 1: Build
FROM node:18-alpine AS builder

WORKDIR /app

# Copiar archivos de dependencias
COPY package*.json ./

# Instalar dependencias
RUN npm ci --only=production && npm cache clean --force

# Stage 2: Runtime
FROM node:18-alpine AS runtime

# Crear usuario no-root
RUN addgroup -g 1001 -S nodejs && \
    adduser -S nodejs -u 1001

WORKDIR /app

# Copiar aplicación y dependencias desde builder
COPY --from=builder /app/node_modules ./node_modules
COPY --chown=nodejs:nodejs src ./src
COPY --chown=nodejs:nodejs package*.json ./

# Configurar usuario
USER nodejs

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD node -e "require('http').get('http://localhost:3000/health', (res) => { \
    process.exit(res.statusCode === 200 ? 0 : 1) \
  }).on('error', () => process.exit(1))"

EXPOSE 3000

CMD ["node", "src/app.js"]

```

<Warning>
Recuerda incluir un `.dockerignore` para optimizar el build:

```

node_modules
npm-debug.log
.git
.gitignore
README.md
tests/
k8s/
.github/

```

</Warning>

## 3. Configuración de Kong Gateway

### Script de configuración

Crea un script para registrar automáticamente el servicio en Kong:

<Tabs>
<Tab title="scripts/setup-kong.sh">

```bash
#!/bin/bash

SERVICE_NAME="my-new-service"
SERVICE_HOST="my-new-service.default.svc.cluster.local"
SERVICE_PORT="3000"
KONG_ADMIN_URL="${KONG_ADMIN_URL:-http://kong-admin:8001}"

echo "Configurando $SERVICE_NAME en Kong..."

# 1. Crear upstream
curl -X POST $KONG_ADMIN_URL/upstreams \
  --data "name=$SERVICE_NAME-upstream" \
  --data "algorithm=round-robin" \
  --data "healthchecks.active.healthy.interval=30" \
  --data "healthchecks.active.http_path=/health"

# 2. Agregar target al upstream
curl -X POST $KONG_ADMIN_URL/upstreams/$SERVICE_NAME-upstream/targets \
  --data "target=$SERVICE_HOST:$SERVICE_PORT"

# 3. Crear servicio
curl -X POST $KONG_ADMIN_URL/services \
  --data "name=$SERVICE_NAME" \
  --data "host=$SERVICE_NAME-upstream" \
  --data "port=80" \
  --data "protocol=http"

# 4. Crear ruta
curl -X POST $KONG_ADMIN_URL/services/$SERVICE_NAME/routes \
  --data "name=$SERVICE_NAME-route" \
  --data "paths[]=/api/$SERVICE_NAME" \
  --data "methods[]=GET" \
  --data "methods[]=POST" \
  --data "methods[]=PUT" \
  --data "methods[]=DELETE"

# 5. Configurar plugins

# Rate limiting
curl -X POST $KONG_ADMIN_URL/services/$SERVICE_NAME/plugins \
  --data "name=rate-limiting" \
  --data "config.minute=60" \
  --data "config.hour=1000"

# CORS
curl -X POST $KONG_ADMIN_URL/services/$SERVICE_NAME/plugins \
  --data "name=cors" \
  --data "config.origins=*" \
  --data "config.methods=GET,POST,PUT,DELETE" \
  --data "config.headers=Accept,Authorization,Content-Type,X-Requested-With"

# OAuth2 (si requiere autenticación)
curl -X POST $KONG_ADMIN_URL/services/$SERVICE_NAME/plugins \
  --data "name=oauth2" \
  --data "config.scopes=read,write" \
  --data "config.enable_authorization_code=true"

echo "Configuración de Kong completada para $SERVICE_NAME"

```

</Tab>

<Tab title="config/kong.js">

```javascript
const axios = require('axios');
const config = require('./env');
const logger = require('../utils/logger');

class KongConfig {
  constructor() {
    this.adminUrl = config.kong.adminUrl;
    this.serviceName = config.serviceName;
  }

  async registerService() {
    try {
      // Verificar si el servicio ya existe
      const existingService = await this.getService();

      if (existingService) {
        logger.info(`Servicio ${this.serviceName} ya existe en Kong`);
        return;
      }

      // Crear upstream
      await this.createUpstream();

      // Crear servicio
      await this.createService();

      // Crear ruta
      await this.createRoute();

      // Configurar plugins
      await this.setupPlugins();

      logger.info(`Servicio ${this.serviceName} registrado exitosamente en Kong`);
    } catch (error) {
      logger.error('Error al registrar servicio en Kong:', error);
      throw error;
    }
  }

  async getService() {
    try {
      const response = await axios.get(`${this.adminUrl}/services/${this.serviceName}`);
      return response.data;
    } catch (error) {
      if (error.response?.status === 404) {
        return null;
      }
      throw error;
    }
  }

  async createUpstream() {
    const upstreamData = {
      name: `${this.serviceName}-upstream`,
      algorithm: 'round-robin',
      'healthchecks.active.healthy.interval': 30,
      'healthchecks.active.http_path': '/health'
    };

    await axios.post(`${this.adminUrl}/upstreams`, upstreamData);

    // Agregar target
    const targetData = {
      target: `${this.serviceName}.default.svc.cluster.local:3000`
    };

    await axios.post(
      `${this.adminUrl}/upstreams/${this.serviceName}-upstream/targets`,
      targetData
    );
  }

  async createService() {
    const serviceData = {
      name: this.serviceName,
      host: `${this.serviceName}-upstream`,
      port: 80,
      protocol: 'http'
    };

    await axios.post(`${this.adminUrl}/services`, serviceData);
  }

  async createRoute() {
    const routeData = {
      name: `${this.serviceName}-route`,
      'paths[]': `/api/${this.serviceName}`,
      'methods[]': ['GET', 'POST', 'PUT', 'DELETE']
    };

    await axios.post(`${this.adminUrl}/services/${this.serviceName}/routes`, routeData);
  }

  async setupPlugins() {
    const plugins = [
      {
        name: 'rate-limiting',
        config: {
          minute: 60,
          hour: 1000
        }
      },
      {
        name: 'cors',
        config: {
          origins: '*',
          methods: 'GET,POST,PUT,DELETE',
          headers: 'Accept,Authorization,Content-Type,X-Requested-With'
        }
      }
    ];

    for (const plugin of plugins) {
      await axios.post(`${this.adminUrl}/services/${this.serviceName}/plugins`, plugin);
    }
  }
}

module.exports = KongConfig;

```

</Tab>

```

</Tab>
</Tabs>

## 4. Manifiestos de Kubernetes

<Tabs>
<Tab title="k8s/deployment.yaml">

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-new-service
  labels:
    app: my-new-service
    version: v1
    tier: backend
spec:
  replicas: 2
  selector:
    matchLabels:
      app: my-new-service
  template:
    metadata:
      labels:
        app: my-new-service
        version: v1
    spec:
      containers:
      - name: my-new-service
        image: retrogamecloud/my-new-service:latest
        ports:
        - containerPort: 3000
          protocol: TCP
        env:
        - name: NODE_ENV
          value: "production"
        - name: SERVICE_NAME
          value: "my-new-service"
        - name: PORT
          value: "3000"
        envFrom:
        - configMapRef:
            name: my-new-service-config
        - secretRef:
            name: my-new-service-secrets
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /health
            port: 3000
          initialDelaySeconds: 30

```

</Tab>
</Tabs>

```

```