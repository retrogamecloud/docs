---
title: GuÃ­a de Desarrollo de Nuevos Microservicios
description: Tutorial completo para agregar un nuevo microservicio al ecosistema RetroGameCloud
  siguiendo los patrones establecidos - desde scaffolding hasta producciÃ³n
icon: microchip
---

# GuÃ­a de desarrollo de nuevos microservicios

Esta guÃ­a te llevarÃ¡ paso a paso por el proceso de creaciÃ³n e integraciÃ³n de un nuevo microservicio en RetroGameCloud, asegurando la consistencia con los patrones arquitectÃ³nicos establecidos.

## Prerrequisitos

<Note>
Antes de comenzar, asegÃºrate de tener acceso a:

- Repositorio del proyecto en GitHub
- Cluster de AWS EKS
- Kong Gateway configurado
- ArgoCD instalado
- Variables de entorno del proyecto
- Node.js 18+ y npm/yarn
- Docker Desktop
- kubectl configurado
- Prisma CLI instalado globalmente
</Note>

## 1. Scaffolding inicial del proyecto

### Clonando el template base

Comienza clonando nuestro template de microservicio:

```bash
# Clonar template
git clone https://github.com/retrogamecloud/microservice-template.git my-new-service
cd my-new-service

# Remover origen del template
git remote remove origin

# Configurar nuevo repositorio
git remote add origin https://github.com/retrogamecloud/my-new-service.git
```

### Estructura del proyecto generada

El template incluye la siguiente estructura optimizada:

```
my-new-service/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ controllers/
â”‚   â”‚   â”œâ”€â”€ index.ts
â”‚   â”‚   â””â”€â”€ healthController.ts
â”‚   â”œâ”€â”€ routes/
â”‚   â”‚   â”œâ”€â”€ index.ts
â”‚   â”‚   â””â”€â”€ api.ts
â”‚   â”œâ”€â”€ models/
â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”œâ”€â”€ middlewares/
â”‚   â”‚   â”œâ”€â”€ auth.ts
â”‚   â”‚   â”œâ”€â”€ validation.ts
â”‚   â”‚   â”œâ”€â”€ rateLimiting.ts
â”‚   â”‚   â””â”€â”€ errorHandler.ts
â”‚   â”œâ”€â”€ config/
â”‚   â”‚   â”œâ”€â”€ database.ts
â”‚   â”‚   â”œâ”€â”€ kong.ts
â”‚   â”‚   â””â”€â”€ env.ts
â”‚   â”œâ”€â”€ utils/
â”‚   â”‚   â”œâ”€â”€ logger.ts
â”‚   â”‚   â””â”€â”€ response.ts
â”‚   â”œâ”€â”€ types/
â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â””â”€â”€ app.ts
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ unit/
â”‚   â”œâ”€â”€ integration/
â”‚   â””â”€â”€ __mocks__/
â”œâ”€â”€ prisma/
â”‚   â”œâ”€â”€ schema.prisma
â”‚   â”œâ”€â”€ migrations/
â”‚   â””â”€â”€ seeds/
â”œâ”€â”€ k8s/
â”‚   â”œâ”€â”€ base/
â”‚   â”‚   â”œâ”€â”€ deployment.yaml
â”‚   â”‚   â”œâ”€â”€ service.yaml
â”‚   â”‚   â”œâ”€â”€ configmap.yaml
â”‚   â”‚   â””â”€â”€ hpa.yaml
â”‚   â”œâ”€â”€ overlays/
â”‚   â”‚   â”œâ”€â”€ staging/
â”‚   â”‚   â””â”€â”€ production/
â”œâ”€â”€ .github/
â”‚   â””â”€â”€ workflows/
â”‚       â”œâ”€â”€ ci.yml
â”‚       â””â”€â”€ cd.yml
â”œâ”€â”€ Dockerfile
â”œâ”€â”€ docker-compose.yml
â”œâ”€â”€ package.json
â”œâ”€â”€ tsconfig.json
â”œâ”€â”€ jest.config.js
â”œâ”€â”€ .dockerignore
â”œâ”€â”€ .gitignore
â””â”€â”€ README.md
```

## 2. ConfiguraciÃ³n de Express + TypeScript

### ConfiguraciÃ³n base del servicio

<Tabs>
<Tab title="src/app.ts">

```typescript
import express from 'express';
import cors from 'cors';
import helmet from 'helmet';
import compression from 'compression';
import { rateLimit } from 'express-rate-limit';
import { errorHandler, notFoundHandler } from './middlewares/errorHandler';
import { requestLogger } from './middlewares/logger';
import { authMiddleware } from './middlewares/auth';
import routes from './routes';
import config from './config/env';
import logger from './utils/logger';
import { connectDatabase } from './config/database';

const app = express();

// Security middlewares
app.use(helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      scriptSrc: ["'self'"],
    },
  },
}));

// CORS configuration
app.use(cors({
  origin: config.ALLOWED_ORIGINS.split(','),
  credentials: true,
}));

// Compression
app.use(compression());

// Rate limiting
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // limit each IP to 100 requests per windowMs
  message: 'Too many requests from this IP',
});
app.use(limiter);

// Body parsing
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true }));

// Request logging
app.use(requestLogger);

// Health check (before auth)
app.get('/health', (req, res) => {
  res.status(200).json({ 
    status: 'ok', 
    timestamp: new Date().toISOString(),
    service: config.SERVICE_NAME,
    version: config.SERVICE_VERSION
  });
});

// Authentication middleware
app.use('/api', authMiddleware);

// Routes
app.use('/api', routes);

// Error handling
app.use(notFoundHandler);
app.use(errorHandler);

// Start server
const startServer = async () => {
  try {
    await connectDatabase();
    
    const port = config.PORT || 3000;
    app.listen(port, () => {
      logger.info(`${config.SERVICE_NAME} running on port ${port}`);
    });
  } catch (error) {
    logger.error('Failed to start server:', error);
    process.exit(1);
  }
};

if (require.main === module) {
  startServer();
}

export default app;
```

</Tab>
<Tab title="src/config/env.ts">

```typescript
import dotenv from 'dotenv';
import { z } from 'zod';

dotenv.config();

const envSchema = z.object({
  NODE_ENV: z.enum(['development', 'staging', 'production']).default('development'),
  PORT: z.string().transform(Number).default(3000),
  SERVICE_NAME: z.string().default('my-new-service'),
  SERVICE_VERSION: z.string().default('1.0.0'),
  DATABASE_URL: z.string(),
  REDIS_URL: z.string().optional(),
  JWT_SECRET: z.string(),
  KONG_ADMIN_URL: z.string(),
  ALLOWED_ORIGINS: z.string().default('*'),
  LOG_LEVEL: z.enum(['error', 'warn', 'info', 'debug']).default('info'),
});

const config = envSchema.parse(process.env);

export default config;
```

</Tab>
<Tab title="package.json">

```json
{
  "name": "my-new-service",
  "version": "1.0.0",
  "description": "Nuevo microservicio para RetroGameCloud",
  "main": "dist/app.js",
  "scripts": {
    "build": "tsc",
    "start": "node dist/app.js",
    "dev": "ts-node-dev --respawn --transpile-only src/app.ts",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage",
    "lint": "eslint src --ext .ts",
    "lint:fix": "eslint src --ext .ts --fix",
    "prisma:generate": "prisma generate",
    "prisma:migrate": "prisma migrate dev",
    "prisma:deploy": "prisma migrate deploy",
    "prisma:seed": "ts-node prisma/seed.ts"
  },
  "dependencies": {
    "express": "^4.18.2",
    "cors": "^2.8.5",
    "helmet": "^7.0.0",
    "compression": "^1.7.4",
    "express-rate-limit": "^6.8.1",
    "@prisma/client": "^5.1.1",
    "jsonwebtoken": "^9.0.1",
    "bcryptjs": "^2.4.3",
    "zod": "^3.21.4",
    "winston": "^3.10.0",
    "dotenv": "^16.3.1"
  },
  "devDependencies": {
    "@types/node": "^20.4.5",
    "@types/express": "^4.17.17",
    "@types/cors": "^2.8.13",
    "@types/compression": "^1.7.2",
    "@types/jsonwebtoken": "^9.0.2",
    "@types/bcryptjs": "^2.4.2",
    "@types/jest": "^29.5.3",
    "@types/supertest": "^2.0.12",
    "typescript": "^5.1.6",
    "ts-node": "^10.9.1",
    "ts-node-dev": "^2.0.0",
    "jest": "^29.6.1",
    "ts-jest": "^29.1.1",
    "supertest": "^6.3.3",
    "prisma": "^5.1.1",
    "@typescript-eslint/eslint-plugin": "^6.2.1",
    "@typescript-eslint/parser": "^6.2.1",
    "eslint": "^8.45.0"
  }
}
```

</Tab>
</Tabs>

## 3. DefiniciÃ³n del esquema de base de datos

### ConfiguraciÃ³n de Prisma

<Tabs>
<Tab title="prisma/schema.prisma">

```prisma
// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  username  String   @unique
  password  String
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relaciones
  profiles UserProfile[]
  sessions UserSession[]

  @@map("users")
}

model UserProfile {
  id     String @id @default(cuid())
  userId String
  avatar String?
  bio    String?
  
  // Relaciones
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("user_profiles")
}

model UserSession {
  id        String   @id @default(cuid())
  userId    String
  token     String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())
  
  // Relaciones
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("user_sessions")
}
```

</Tab>
<Tab title="src/config/database.ts">

```typescript
import { PrismaClient } from '@prisma/client';
import logger from '../utils/logger';

const prisma = new PrismaClient({
  log: ['query', 'info', 'warn', 'error'],
});

export const connectDatabase = async () => {
  try {
    await prisma.$connect();
    logger.info('Database connected successfully');
  } catch (error) {
    logger.error('Database connection failed:', error);
    throw error;
  }
};

export const disconnectDatabase = async () => {
  try {
    await prisma.$disconnect();
    logger.info('Database disconnected successfully');
  } catch (error) {
    logger.error('Database disconnection failed:', error);
  }
};

// Handle graceful shutdown
process.on('SIGINT', async () => {
  await disconnectDatabase();
  process.exit(0);
});

process.on('SIGTERM', async () => {
  await disconnectDatabase();
  process.exit(0);
});

export default prisma;
```

</Tab>
<Tab title="prisma/seed.ts">

```typescript
import { PrismaClient } from '@prisma/client';
import bcrypt from 'bcryptjs';

const prisma = new PrismaClient();

async function main() {
  console.log('ðŸŒ± Seeding database...');

  // Create test users
  const hashedPassword = await bcrypt.hash('password123', 10);

  const user1 = await prisma.user.create({
    data: {
      email: 'test@example.com',
      username: 'testuser',
      password: hashedPassword,
      profiles: {
        create: {
          bio: 'Test user for development',
        },
      },
    },
    include: {
      profiles: true,
    },
  });

  console.log('âœ… Created user:', user1);
}

main()
  .catch((e) => {
    console.error('âŒ Seeding failed:', e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });
```

</Tab>
</Tabs>

### Crear y ejecutar migraciones

```bash
# Generar cliente Prisma
npm run prisma:generate

# Crear primera migraciÃ³n
npm run prisma:migrate -- --name init

# Ejecutar seeds
npm run prisma:seed
```

## 4. ImplementaciÃ³n de endpoints con validaciÃ³n

### Controllers con validaciÃ³n Zod

<Tabs>
<Tab title="src/controllers/userController.ts">

```typescript
import { Request, Response, NextFunction } from 'express';
import { z } from 'zod';
import bcrypt from 'bcryptjs';
import jwt from 'jsonwebtoken';
import prisma from '../config/database';
import config from '../config/env';
import { ApiResponse } from '../utils/response';
import logger from '../utils/logger';

// Validation schemas
const createUserSchema = z.object({
  email: z.string().email(),
  username: z.string().min(3).max(50),
  password: z.string().min(6),
  bio: z.string().optional(),
});

const loginSchema = z.object({
  email: z.string().email(),
  password: z.string().min(1),
});

export class UserController {
  static async createUser(req: Request, res: Response, next: NextFunction) {
    try {
      const validatedData = createUserSchema.parse(req.body);
      
      // Check if user already exists
      const existingUser = await prisma.user.findFirst({
        where: {
          OR: [
            { email: validatedData.email },
            { username: validatedData.username },
          ],
        },
      });

      if (existingUser) {
        return ApiResponse.error(res, 'User already exists', 409);
      }

      // Hash password
      const hashedPassword = await bcrypt.hash(validatedData.password, 10);

      // Create user with profile
      const user = await prisma.user.create({
        data: {
          email: validatedData.email,
          username: validatedData.username,
          password: hashedPassword,
          profiles: {
            create: {
              bio: validatedData.bio,
            },
          },
        },
        select: {
          id: true,
          email: true,
          username: true,
          isActive: true,
          createdAt: true,
          profiles: {
            select: {
              bio: true,
              avatar: true,
            },
          },
        },
      });

      logger.info(`User created: ${user.id}`);
      
      return ApiResponse.success(res, user, 'User created successfully', 201
</Tabs>
```