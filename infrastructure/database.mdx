---
title: Esquema y Arquitectura de Base de Datos
description: Documentaci√≥n completa del modelo de datos PostgreSQL, relaciones entre
  tablas, √≠ndices, migraciones y estrategias de gesti√≥n para RetroGameCloud
icon: database
---

# Esquema y Arquitectura de Base de Datos

Esta documentaci√≥n describe la arquitectura completa de la base de datos PostgreSQL utilizada en RetroGameCloud, incluyendo el modelo de datos, relaciones, √≠ndices, migraciones y estrategias de gesti√≥n.

## Visi√≥n General

RetroGameCloud utiliza PostgreSQL 14 alojado en Amazon RDS con configuraci√≥n Multi-AZ para alta disponibilidad. La base de datos gestiona usuarios, juegos, puntuaciones y rankings con un dise√±o optimizado para consultas de lectura intensiva.

<Note>
La base de datos est√° compartida entre m√∫ltiples microservicios, cada uno accediendo √∫nicamente a las tablas de su dominio espec√≠fico.
</Note>

## Diagrama del Modelo de Datos

```mermaid
erDiagram
    USERS ||--o{ SCORES : guarda
    USERS ||--o{ RANKINGS : aparece
    GAMES ||--o{ SCORES : tiene
    GAMES ||--o{ RANKINGS : tiene
    USERS {
        uuid id PK
        varchar username UK
        varchar email UK
        varchar password_hash
        varchar display_name
        varchar avatar_url
        text bio
        timestamp created_at
        timestamp updated_at
        boolean is_active
    }
    GAMES {
        uuid id PK
        varchar slug UK
        varchar name
        text description
        varchar jsdos_url
        varchar thumbnail_url
        varchar category
        int year
        boolean is_published
        timestamp created_at
        timestamp updated_at
    }
    SCORES {
        uuid id PK
        uuid user_id FK
        uuid game_id FK
        int score
        json metadata
        timestamp achieved_at
        timestamp created_at
        boolean is_verified
    }
    RANKINGS {
        uuid id PK
        uuid game_id FK
        uuid user_id FK
        int rank
        int score
        timestamp updated_at
        timestamp created_at
    }

```

## Gesti√≥n de Migraciones

### Herramientas de Migraci√≥n

RetroGameCloud utiliza **Knex.js** como herramienta principal para la gesti√≥n de migraciones de esquema de base de datos.

#### Estructura de Archivos

```

database/
‚îú‚îÄ‚îÄ migrations/
‚îÇ   ‚îú‚îÄ‚îÄ 20231201_001_create_users_table.js
‚îÇ   ‚îú‚îÄ‚îÄ 20231201_002_create_games_table.js
‚îÇ   ‚îî‚îÄ‚îÄ 20231201_003_create_scores_table.js
‚îú‚îÄ‚îÄ seeds/
‚îÇ   ‚îú‚îÄ‚îÄ 01_users.js
‚îÇ   ‚îî‚îÄ‚îÄ 02_games.js
‚îî‚îÄ‚îÄ knexfile.js

```

### Creaci√≥n de Migraciones

#### 1. Generar Nueva Migraci√≥n

```bash

# Crear migraci√≥n con timestamp autom√°tico
npx knex migrate:make add_user_preferences_table

# Crear migraci√≥n con nombre espec√≠fico
npx knex migrate:make add_oauth_providers --timestamp-format YYYYMMDD_HHmm

```

#### 2. Estructura de Migraci√≥n

```javascript
// migrations/20231215_001_add_user_preferences.js
exports.up = function(knex) {
  return knex.schema.createTable('user_preferences', function(table) {
    table.uuid('id').primary().defaultTo(knex.raw('gen_random_uuid()'));
    table.uuid('user_id').notNullable();
    table.string('theme').defaultTo('dark');
    table.boolean('email_notifications').defaultTo(true);
    table.json('game_settings').defaultTo('{}');
    table.timestamp('created_at').defaultTo(knex.fn.now());
    table.timestamp('updated_at').defaultTo(knex.fn.now());

    // √çndices y constrains
    table.foreign('user_id').references('id').inTable('users').onDelete('CASCADE');
    table.index(['user_id']);
  });
};

exports.down = function(knex) {
  return knex.schema.dropTableIfExists('user_preferences');
};

```

### Estrategias para Cambios Breaking

#### Adici√≥n de Columnas NOT NULL

* *‚ùå Incorrecto - Causa downtime:**

```javascript
exports.up = function(knex) {
  return knex.schema.alterTable('users', function(table) {
    table.string('phone').notNullable(); // Error: filas existentes no tienen valor
  });
};

```

* *‚úÖ Correcto - Zero downtime:**

```javascript
// Migraci√≥n 1: A√±adir columna como nullable
exports.up = function(knex) {
  return knex.schema.alterTable('users', function(table) {
    table.string('phone').nullable();
  });
};

// Migraci√≥n 2: Poblar datos (despu√©s del deploy)
exports.up = function(knex) {
  return knex('users')
    .whereNull('phone')
    .update({ phone: 'pending-verification' });
};

// Migraci√≥n 3: Hacer NOT NULL (pr√≥ximo deploy)
exports.up = function(knex) {
  return knex.schema.alterTable('users', function(table) {
    table.string('phone').notNullable().alter();
  });
};

```

#### Eliminaci√≥n de Columnas

```javascript
// Paso 1: Marcar columna como deprecated (comentario)
// Paso 2: Remover uso en c√≥digo
// Paso 3: Deploy sin uso de la columna
// Paso 4: Migraci√≥n para eliminar columna
exports.up = function(knex) {
  return knex.schema.alterTable('users', function(table) {
    table.dropColumn('old_field');
  });
};

```

#### Cambios de Tipo de Datos

```javascript
// Para cambios de tipo que pueden fallar
exports.up = async function(knex) {
  // Crear nueva columna
  await knex.schema.alterTable('scores', function(table) {
    table.bigInteger('score_new');
  });

  // Migrar datos con validaci√≥n
  await knex.raw(`
    UPDATE scores
    SET score_new = CASE
      WHEN score::text ~ '^[0-9]+$' THEN score::bigint
      ELSE 0
    END
  `);

  // En migraci√≥n posterior: drop old, rename new
  return Promise.resolve();
};

```

### Proceso de Testing

#### 1. Testing Local

```bash

# Resetear base de datos local
npm run db:reset

# Aplicar migraciones
npm run db:migrate

# Verificar con seeds
npm run db:seed

# Ejecutar tests
npm run test:integration

```

#### 2. Testing en Staging

```yaml

# .github/workflows/test-migration.yml
name: Test Database Migration
on:
  pull_request:
    paths: ['database/migrations/**']

jobs:
  test-migration:
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:14
        env:
          POSTGRES_PASSWORD: test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    steps:
      - uses: actions/checkout@v3
      - name: Test Migration Up
        run: npm run db:migrate
      - name: Seed Test Data
        run: npm run db:seed
      - name: Run Integration Tests
        run: npm run test:integration
      - name: Test Migration Down
        run: npm run db:rollback

```

#### 3. Dry Run en Staging

```javascript
// scripts/migration-dry-run.js
const knex = require('../database/connection');

async function dryRun() {
  const transaction = await knex.transaction();

  try {
    console.log('üß™ Iniciando dry run...');

    // Aplicar migraci√≥n en transacci√≥n
    await transaction.migrate.latest();

    // Verificar integridad
    const healthCheck = await runHealthChecks(transaction);

    if (healthCheck.success) {
      console.log('‚úÖ Migraci√≥n simulada exitosa');
    } else {
      throw new Error(`Health check failed: ${healthCheck.errors}`);
    }

    // Rollback para no aplicar cambios
    await transaction.rollback();

  } catch (error) {
    console.error('‚ùå Dry run fall√≥:', error);
    await transaction.rollback();
    process.exit(1);
  }
}

```

### Aplicaci√≥n en Producci√≥n

#### Zero-Downtime Migrations

```javascript
// knexfile.js - Configuraci√≥n para producci√≥n
module.exports = {
  production: {
    client: 'postgresql',
    connection: {
      host: process.env.DB_HOST,
      port: process.env.DB_PORT,
      database: process.env.DB_NAME,
      user: process.env.DB_USER,
      password: process.env.DB_PASSWORD,
      ssl: { rejectUnauthorized: false }
    },
    migrations: {
      tableName: 'knex_migrations',
      directory: './migrations',
      schemaName: 'public'
    },
    pool: {
      min: 2,
      max: 20,
      acquireTimeoutMillis: 30000,
      createTimeoutMillis: 30000,
      destroyTimeoutMillis: 5000,
      idleTimeoutMillis: 30000,
      reapIntervalMillis: 1000,
      createRetryIntervalMillis: 100
    }
  }
};

```

#### Script de Aplicaci√≥n Automatizada

```bash
#!/bin/bash

# scripts/apply-migration.sh

set -e

echo "üöÄ Iniciando aplicaci√≥n de migraci√≥n en producci√≥n..."

# Verificar conexi√≥n
echo "üîç Verificando conexi√≥n a base de datos..."
npm run db:status || exit 1

# Backup autom√°tico
echo "üíæ Creando backup de seguridad..."
pg_dump $DATABASE_URL > "backup_$(date +%Y%m%d_%H%M%S).sql"

# Dry run
echo "üß™ Ejecutando dry run..."
npm run migration:dry-run || exit 1

# Aplicar migraci√≥n
echo "‚ö° Aplicando migraci√≥n..."
npm run db:migrate

# Health check post-migraci√≥n
echo "üè• Ejecutando health checks..."
npm run health:check || {
  echo "‚ùå Health check fall√≥ - Iniciando rollback autom√°tico"
  npm run db:rollback
  exit 1
}

echo "‚úÖ Migraci√≥n aplicada exitosamente"

```

### Plan de Rollback Autom√°tico

#### Configuraci√≥n de Health Checks

```javascript
// scripts/health-check.js
const knex = require('../database/connection');

async function healthCheck() {
  const checks = [
    {
      name: 'database-connection',
      check: () => knex.raw('SELECT 1')
    },
    {
      name: 'users-table-integrity',
      check: () => knex('users').count('*').first()
    },
    {
      name: 'foreign-key-constraints',
      check: () => knex.raw(`
        SELECT COUNT(*) as violations
        FROM information_schema.table_constraints
        WHERE constraint_type = 'FOREIGN KEY'
        AND constraint_name LIKE '%_violated'
      `)
    }
  ];

  const results = [];

  for (const { name, check } of checks) {
    try {
      await check();
      results.push({ name, status: 'OK' });
    } catch (error) {
      results.push({ name, status: 'FAILED', error: error.message });
    }
  }

  const failed = results.filter(r => r.status === 'FAILED');

  return {
    success: failed.length === 0,
    results,
    errors: failed.map(f => `${f.name}: ${f.error}`)
  };
}

```

#### Rollback Autom√°tico

```javascript
// scripts/auto-rollback.js
async function autoRollback() {
  console.log('üîÑ Iniciando rollback autom√°tico...');

  try {
    // Obtener √∫ltima migraci√≥n aplicada
    const [lastBatch] = await knex('knex_migrations')
      .max('batch as batch')
      .first();

    if (lastBatch.batch) {
      // Rollback del √∫ltimo batch
      await knex.migrate.rollback();

      // Verificar que el rollback fue exitoso
      const healthCheck = await runHealthChecks();

      if (healthCheck.success) {
        console.log('‚úÖ Rollback completado exitosamente');

        // Notificar al equipo
        await notifyTeam({
          status: 'rollback-success',
          migration: lastBatch,
          timestamp: new Date()
        });
      } else {
        throw new Error('Health check fall√≥ despu√©s del rollback');
      }
    }
  } catch (error) {
    console.error('‚ùå Rollback fall√≥:', error);

    // Notificaci√≥n cr√≠tica
    await notifyTeam({
      status: 'rollback-failed',
      error: error.message,
      timestamp: new Date(),
      priority: 'critical'
    });
  }
}

```

### Checklist Pre-Migraci√≥n

<Tabs>
<Tab title="Desarrollo">

```markdown

## ‚úÖ Checklist - Desarrollo

### Antes de crear la migraci√≥n:

- [ ] Analizar impacto en consultas existentes

- [ ] Verificar que no hay breaking changes

- [ ] Documentar cambios en esquema

- [ ] Escribir tests para nueva estructura

### Al escribir la migraci√≥n:

- [ ] Incluir funci√≥n `down` para rollback

- [ ] Usar transacciones cuando sea necesario

- [ ] Validar que funciona con datos existentes

- [ ] A√±adir √≠ndices necesarios

### Testing:

- [ ] Probar migraci√≥n up/down localmente

- [ ] Ejecutar suite completa de tests

- [ ] Verificar performance de queries afectadas

- [ ] Validar con datos de volumen similar a producci√≥n

```

</Tab>

<Tab title="Staging">

```markdown

## ‚úÖ Checklist - Staging

### Preparaci√≥n:

- [ ] Sincronizar datos con snapshot de producci√≥n

- [ ] Verificar versi√≥n de PostgreSQL coincida

- [ ] Configurar monitoreo de performance

### Ejecuci√≥n:

- [ ] Ejecutar dry-run exitosamente

- [ ] Aplicar migraci√≥n en staging

- [ ] Verificar funcionalidad completa de aplicaci√≥n

- [ ] Medir tiempo de ejecuci√≥n de migraci√≥n

### Validaci√≥n:

- [ ] Health checks pasan

- [ ] Tests de integraci√≥n pasan

- [ ] Performance tests dentro de par√°metros

- [ ] Rollback funciona correctamente

```

</Tab>

<Tab title="Producci√≥n">

```markdown

## ‚úÖ Checklist - Producci√≥n

### Pre-migraci√≥n (24h antes):

- [ ] Coordinar ventana de mantenimiento

- [ ] Notificar a stakeholders

- [ ] Preparar scripts de rollback

- [ ] Verificar espacio en disco para backup

### Pre-migraci√≥n (inmediato):

- [ ] Crear backup completo de base de datos

- [ ] Verificar conectividad y permisos

- [ ] Confirmar que staging tests pasaron

- [ ] Alertar a equipo de DevOps

### Durante la migraci√≥n:

- [ ] Monitorear logs en tiempo real

- [ ] Verificar m√©tricas de sistema

- [ ] Confirmar health checks post-migraci√≥n

- [ ] Validar funcionalidad cr√≠tica

### Post-migraci√≥n:

- [
</Tab>
</Tabs>

```