---
title: 4.10. Escalado y Dimensionamiento
description: Estrategias de escalado horizontal y vertical, configuración de autoscaling,
  y planificación de capacidad para los componentes de RetroGameCloud
icon: chart-line
---

# 4.10. Escalado y Dimensionamiento

Esta guía describe las estrategias de escalado para cada componente de RetroGameCloud, incluyendo configuración de autoscaling automático, umbrales críticos y planificación de capacidad.

## 4.10.1. Estrategias de Escalado por Componente

### 4.10.1.1. Escalado de Microservicios en EKS

<Tabs>
<Tab title="Horizontal Pod Autoscaler">

```yaml

# hpa-auth-service.yaml
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: auth-service-hpa
  namespace: retrogame
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: auth-service
  minReplicas: 2
  maxReplicas: 20
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80
  behavior:
    scaleUp:
      stabilizationWindowSeconds: 60
      policies:
      - type: Percent
        value: 100
        periodSeconds: 15
    scaleDown:
      stabilizationWindowSeconds: 300
      policies:
      - type: Percent
        value: 50
        periodSeconds: 60

```

</Tab>
<Tab title="Vertical Pod Autoscaler">

```yaml

# vpa-game-catalog.yaml
apiVersion: autoscaling.k8s.io/v1
kind: VerticalPodAutoscaler
metadata:
  name: game-catalog-vpa
  namespace: retrogame
spec:
  targetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: game-catalog-service
  updatePolicy:
    updateMode: "Auto"
  resourcePolicy:
    containerPolicies:
    - containerName: game-catalog
      minAllowed:
        cpu: 100m
        memory: 128Mi
      maxAllowed:
        cpu: 2
        memory: 2Gi
      controlledResources: ["cpu", "memory"]

```

</Tab>
<Tab title="Cluster Autoscaler">

```yaml

# cluster-autoscaler.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: cluster-autoscaler
  namespace: kube-system
spec:
  selector:
    matchLabels:
      app: cluster-autoscaler
  template:
    metadata:
      labels:
        app: cluster-autoscaler
    spec:
      containers:
      - image: registry.k8s.io/autoscaling/cluster-autoscaler:v1.27.0
        name: cluster-autoscaler
        resources:
          limits:
            cpu: 100m
            memory: 300Mi
          requests:
            cpu: 100m
            memory: 300Mi
        command:
        - ./cluster-autoscaler
        - --v=4
        - --stderrthreshold=info
        - --cloud-provider=aws
        - --skip-nodes-with-local-storage=false
        - --expander=least-waste
        - --node-group-auto-discovery=asg:tag=k8s.io/cluster-autoscaler/enabled,k8s.io/cluster-autoscaler/retrogame-cluster
        - --balance-similar-node-groups
        - --scale-down-delay-after-add=10m
        - --scale-down-unneeded-time=10m

```

</Tab>
</Tabs>

<Note>
El HPA escala pods basándose en métricas de CPU y memoria, mientras que el VPA ajusta los recursos de pods individuales. El Cluster Autoscaler gestiona la cantidad de nodos en el cluster.
</Note>

### 4.10.1.2. Escalado de Base de Datos

<Tabs>
<Tab title="RDS Aurora Escalado">

```yaml

# terraform/rds-scaling.tf
resource "aws_rds_cluster" "aurora_cluster" {
  cluster_identifier      = "retrogame-aurora-cluster"
  engine                 = "aurora-mysql"
  engine_version         = "8.0.mysql_aurora.3.02.0"
  availability_zones     = ["us-west-2a", "us-west-2b", "us-west-2c"]
  database_name          = "retrogame"
  master_username        = var.db_username
  master_password        = var.db_password
  backup_retention_period = 5
  preferred_backup_window = "07:00-09:00"

  serverlessv2_scaling_configuration {
    max_capacity = 64
    min_capacity = 0.5
  }

  tags = {
    Environment = var.environment
    Project     = "RetroGameCloud"
  }
}

resource "aws_appautoscaling_target" "aurora_read_replica" {
  max_capacity       = 10
  min_capacity       = 1
  resource_id        = "cluster:${aws_rds_cluster.aurora_cluster.cluster_identifier}"
  scalable_dimension = "rds:cluster:ReadReplicaCount"
  service_namespace  = "rds"
}

resource "aws_appautoscaling_policy" "aurora_scale_up" {
  name               = "aurora-scale-up"
  policy_type        = "TargetTrackingScaling"
  resource_id        = aws_appautoscaling_target.aurora_read_replica.resource_id
  scalable_dimension = aws_appautoscaling_target.aurora_read_replica.scalable_dimension
  service_namespace  = aws_appautoscaling_target.aurora_read_replica.service_namespace

  target_tracking_scaling_policy_configuration {
    target_value = 70.0
    predefined_metric_specification {
      predefined_metric_type = "RDSReaderAverageCPUUtilization"
    }
  }
}

```

</Tab>
<Tab title="ElastiCache Escalado">

```yaml

# terraform/elasticache-scaling.tf
resource "aws_elasticache_replication_group" "redis_cluster" {
  replication_group_id         = "retrogame-redis"
  description                  = "Redis cluster for RetroGameCloud"

  node_type                    = "cache.r7g.large"
  port                         = 6379
  parameter_group_name         = "default.redis7"

  num_cache_clusters           = 3
  automatic_failover_enabled   = true
  multi_az_enabled            = true

  subnet_group_name           = aws_elasticache_subnet_group.redis_subnet_group.name
  security_group_ids          = [aws_security_group.redis.id]

  at_rest_encryption_enabled  = true
  transit_encryption_enabled  = true

  tags = {
    Environment = var.environment
    Project     = "RetroGameCloud"
  }
}

# Configuración de autoscaling para ElastiCache
resource "aws_appautoscaling_target" "redis_target" {
  max_capacity       = 10
  min_capacity       = 3
  resource_id        = "replication-group/${aws_elasticache_replication_group.redis_cluster.replication_group_id}"
  scalable_dimension = "elasticache:replication-group:Replicas"
  service_namespace  = "elasticache"
}

```

</Tab>
</Tabs>

### 4.10.1.3. Escalado de CDN y Storage

<Tabs>
<Tab title="CloudFront Configuración">

```yaml

# terraform/cloudfront-scaling.tf
resource "aws_cloudfront_distribution" "game_assets_distribution" {
  origin {
    domain_name = aws_s3_bucket.game_assets.bucket_regional_domain_name
    origin_id   = "S3-${aws_s3_bucket.game_assets.id}"

    s3_origin_config {
      origin_access_identity = aws_cloudfront_origin_access_identity.oai.cloudfront_access_identity_path
    }
  }

  enabled             = true
  is_ipv6_enabled     = true
  default_root_object = "index.html"

  default_cache_behavior {
    allowed_methods  = ["DELETE", "GET", "HEAD", "OPTIONS", "PATCH", "POST", "PUT"]
    cached_methods   = ["GET", "HEAD"]
    target_origin_id = "S3-${aws_s3_bucket.game_assets.id}"

    forwarded_values {
      query_string = false
      cookies {
        forward = "none"
      }
    }

    viewer_protocol_policy = "redirect-to-https"
    min_ttl                = 0
    default_ttl            = 3600
    max_ttl                = 86400
    compress               = true
  }

  price_class = "PriceClass_All"

  restrictions {
    geo_restriction {
      restriction_type = "none"
    }
  }

  viewer_certificate {
    cloudfront_default_certificate = true
  }

  tags = {
    Environment = var.environment
    Project     = "RetroGameCloud"
  }
}

```

</Tab>
<Tab title="S3 Transfer Acceleration">

```yaml

# terraform/s3-scaling.tf
resource "aws_s3_bucket" "game_assets" {
  bucket = "retrogame-assets-${var.environment}"

  tags = {
    Environment = var.environment
    Project     = "RetroGameCloud"
  }
}

resource "aws_s3_bucket_accelerate_configuration" "game_assets_acceleration" {
  bucket = aws_s3_bucket.game_assets.id
  status = "Enabled"
}

resource "aws_s3_bucket_intelligent_tiering_configuration" "game_assets_tiering" {
  bucket = aws_s3_bucket.game_assets.id
  name   = "GameAssetsArchive"

  status = "Enabled"

  optional_fields = ["BucketKeyStatus", "AccessPointArn"]
}

# Configuración de lifecycle para optimizar costos
resource "aws_s3_bucket_lifecycle_configuration" "game_assets_lifecycle" {
  bucket = aws_s3_bucket.game_assets.id

  rule {
    id     = "game_assets_lifecycle"
    status = "Enabled"

    transition {
      days          = 30
      storage_class = "STANDARD_IA"
    }

    transition {
      days          = 90
      storage_class = "GLACIER"
    }

    transition {
      days          = 365
      storage_class = "DEEP_ARCHIVE"
    }
  }
}

```

</Tab>
</Tabs>

## 4.10.2. Métricas de Escalado y Umbrales

### 4.10.2.1. Métricas Críticas por Componente

<Tabs>
<Tab title="Microservicios">

```yaml

# monitoring/service-metrics.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: scaling-thresholds
  namespace: retrogame
data:
  thresholds.yaml: |
    services:
      auth-service:
        cpu:
          scale_up: 70
          scale_down: 30
        memory:
          scale_up: 80
          scale_down: 40
        response_time:
          max: 200ms
        error_rate:
          max: 1%

      game-catalog-service:
        cpu:
          scale_up: 75
          scale_down: 25
        memory:
          scale_up: 85
          scale_down: 45
        requests_per_second:
          max: 1000
        cache_hit_rate:
          min: 85%

      streaming-service:
        cpu:
          scale_up: 60
          scale_down: 20
        memory:
          scale_up: 70
          scale_down: 30
        bandwidth:
          max: 10Gbps
        concurrent_streams:
          max: 1000

      save-state-service:
        cpu:
          scale_up: 65
          scale_down: 25
        memory:
          scale_up: 75
          scale_down: 35
        disk_io:
          max: 1000_iops
        write_latency:
          max: 10ms

```

</Tab>
<Tab title="Base de Datos">

```yaml

# monitoring/database-metrics.yaml
database:
  aurora_cluster:
    cpu_utilization:
      read_replica_scale_up: 70
      read_replica_scale_down: 30
    connections:
      max: 1000
      scale_threshold: 800
    read_latency:
      max: 20ms
    write_latency:
      max: 50ms

  redis_cluster:
    memory_utilization:
      scale_up: 80
      scale_down: 40
    cpu_utilization:
      scale_up: 75
      scale_down: 35
    network_bytes_in:
      max: 100MB/s
    evictions:
      max: 100/minute

```

</Tab>
<Tab title="Infraestructura">

```yaml

# monitoring/infrastructure-metrics.yaml
infrastructure:
  eks_nodes:
    cpu_utilization:
      scale_up: 80
      scale_down: 40
    memory_utilization:
      scale_up: 85
      scale_down: 45
    disk_utilization:
      warning: 80
      critical: 90

  load_balancer:
    active_connections:
      max: 10000
    target_response_time:
      max: 500ms
    healthy_hosts:
      min: 2

  cloudfront:
    cache_hit_rate:
      min: 85%
    origin_latency:
      max: 1000ms
    error_rate:
      max: 0.5%

```

</Tab>
</Tabs>

### 4.10.2.2. Alertas de Escalado

<Tabs>
<Tab title="PrometheusRule">

```yaml

# monitoring/scaling-alerts.yaml
apiVersion: monitoring.coreos.com/v1
kind: PrometheusRule
metadata:
  name: scaling-alerts
  namespace: retrogame
spec:
  groups:
  - name: scaling.rules
    rules:
    - alert: HighCPUUsage
      expr: |
        (
          sum(rate(container_cpu_usage_seconds_total{namespace="retrogame"}[5m])) by (pod)
          /
          sum(container_spec_cpu_quota{namespace="retrogame"}/container_spec_cpu_period{namespace="retrogame"}) by (pod)
        ) * 100 > 80
      for: 5m
      labels:
        severity: warning
      annotations:
        summary: "High CPU usage detected"
        description: "Pod {{ $labels.pod }} has CPU usage above 80% for 5 minutes"

    - alert: HighMemoryUsage
      expr: |
        (
          sum(container_memory_working_set_bytes{namespace="retrogame"}) by (pod)
          /
          sum(container_spec_memory_limit_bytes{namespace="retrogame"}) by (pod)
        ) * 100 > 85
      for: 5m
      labels:
        severity: warning
      annotations:
        summary: "High memory usage detected"
        description: "Pod {{ $labels.pod }} has memory usage above 85% for 5
</Tab>
</Tab>
</Tab>
</Tab>
</Tab>
</Tabs>

```
