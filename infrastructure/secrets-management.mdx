---
title: Seguridad y Gestión de Secretos
description: Guía completa sobre gestión de secretos, políticas de seguridad y mejores
  prácticas para RetroGameCloud
icon: shield-check
---

## Introducción

La seguridad en RetroGameCloud es fundamental para proteger los datos de usuarios, mantener la integridad de la plataforma y garantizar el cumplimiento normativo. Esta documentación cubre la gestión de secretos, políticas de seguridad y mejores prácticas implementadas en nuestra arquitectura de microservicios.

<Note>
Todos los secretos y credenciales deben seguir el principio de menor privilegio y rotarse regularmente según las políticas establecidas.
</Note>

## Gestión de Secretos

### AWS Secrets Manager

Utilizamos AWS Secrets Manager como solución principal para la gestión de secretos críticos de la aplicación.

#### Secretos Almacenados

<Tabs>
<Tab title="Base de Datos">

```json
{
  "secret_name": "retrogamecloud/postgres/main",
  "description": "Credenciales principales de PostgreSQL",
  "secret_value": {
    "username": "rgc_admin",
    "password": "AUTO_GENERATED",
    "host": "rgc-postgres.cluster-xyz.eu-west-1.rds.amazonaws.com",
    "port": 5432,
    "database": "retrogamecloud"
  }
}

```

</Tab>

<Tab title="JWT Secrets">

```json
{
  "secret_name": "retrogamecloud/jwt/tokens",
  "description": "Secretos para firma de tokens JWT",
  "secret_value": {
    "access_token_secret": "AUTO_GENERATED_256_BIT",
    "refresh_token_secret": "AUTO_GENERATED_256_BIT",
    "token_expiry": "15m",
    "refresh_expiry": "7d"
  }
}

```

</Tab>

<Tab title="OAuth2">

```json
{
  "secret_name": "retrogamecloud/oauth2/providers",
  "description": "Credenciales OAuth2 para proveedores externos",
  "secret_value": {
    "google_client_id": "GOOGLE_CLIENT_ID",
    "google_client_secret": "GOOGLE_CLIENT_SECRET",
    "discord_client_id": "DISCORD_CLIENT_ID",
    "discord_client_secret": "DISCORD_CLIENT_SECRET"
  }
}

```

</Tab>
</Tabs>

#### Configuración de Rotación Automática

```yaml

# cloudformation/secrets-rotation.yml
Resources:
  DatabaseSecretRotation:
    Type: AWS::SecretsManager::RotationSchedule
    Properties:
      SecretId: !Ref DatabaseSecret
      RotationLambdaArn: !GetAtt RotationLambda.Arn
      RotationSchedule:
        ScheduleExpression: "rate(30 days)"

  JWTSecretRotation:
    Type: AWS::SecretsManager::RotationSchedule
    Properties:
      SecretId: !Ref JWTSecret
      RotationLambdaArn: !GetAtt JWTRotationLambda.Arn
      RotationSchedule:
        ScheduleExpression: "rate(90 days)"

```

### AWS Systems Manager Parameter Store

Para configuraciones menos sensibles pero que requieren cifrado, utilizamos Parameter Store.

#### Estructura de Parámetros

```bash

# Configuración de aplicación
/retrogamecloud/config/cors-origins
/retrogamecloud/config/rate-limiting
/retrogamecloud/config/session-timeout

# Configuración de servicios externos
/retrogamecloud/external/s3-bucket-games
/retrogamecloud/external/cloudfront-domain
/retrogamecloud/external/kong-admin-url

```

#### Ejemplo de Uso en Microservicios

```javascript
// services/auth/src/config/secrets.js
const { SecretsManagerClient, GetSecretValueCommand } = require("@aws-sdk/client-secrets-manager");

class SecretsManager {
  constructor() {
    this.client = new SecretsManagerClient({ region: process.env.AWS_REGION });
    this.cache = new Map();
    this.cacheTTL = 300000; // 5 minutos
  }

  async getSecret(secretName) {
    const cacheKey = secretName;
    const cached = this.cache.get(cacheKey);

    if (cached && (Date.now() - cached.timestamp) < this.cacheTTL) {
      return cached.value;
    }

    try {
      const command = new GetSecretValueCommand({ SecretId: secretName });
      const response = await this.client.send(command);
      const secret = JSON.parse(response.SecretString);

      this.cache.set(cacheKey, {
        value: secret,
        timestamp: Date.now()
      });

      return secret;
    } catch (error) {
      console.error(`Error retrieving secret ${secretName}:`, error);
      throw error;
    }
  }

  async getJWTSecrets() {
    return await this.getSecret('retrogamecloud/jwt/tokens');
  }

  async getDatabaseCredentials() {
    return await this.getSecret('retrogamecloud/postgres/main');
  }
}

module.exports = new SecretsManager();

```

## Políticas de Seguridad IAM

### Roles por Microservicio

Cada microservicio tiene un rol IAM específico con permisos mínimos necesarios.

<Tabs>
<Tab title="Auth Service">

```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Action": [
        "secretsmanager:GetSecretValue"
      ],
      "Resource": [
        "arn:aws:secretsmanager:eu-west-1:*:secret:retrogamecloud/jwt/tokens-*",
        "arn:aws:secretsmanager:eu-west-1:*:secret:retrogamecloud/oauth2/providers-*",
        "arn:aws:secretsmanager:eu-west-1:*:secret:retrogamecloud/postgres/main-*"
      ]
    },
    {
      "Effect": "Allow",
      "Action": [
        "ssm:GetParameter",
        "ssm:GetParameters"
      ],
      "Resource": [
        "arn:aws:ssm:eu-west-1:*:parameter/retrogamecloud/config/session-timeout",
        "arn:aws:ssm:eu-west-1:*:parameter/retrogamecloud/config/cors-origins"
      ]
    }
  ]
}

```

</Tab>

<Tab title="Game Catalog Service">

```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Action": [
        "s3:GetObject",
        "s3:PutObject"
      ],
      "Resource": [
        "arn:aws:s3:::retrogamecloud-games/*"
      ]
    },
    {
      "Effect": "Allow",
      "Action": [
        "secretsmanager:GetSecretValue"
      ],
      "Resource": [
        "arn:aws:secretsmanager:eu-west-1:*:secret:retrogamecloud/postgres/main-*"
      ]
    }
  ]
}

```

</Tab>

<Tab title="Score Service">

```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Action": [
        "secretsmanager:GetSecretValue"
      ],
      "Resource": [
        "arn:aws:secretsmanager:eu-west-1:*:secret:retrogamecloud/postgres/main-*"
      ]
    },
    {
      "Effect": "Allow",
      "Action": [
        "cloudwatch:PutMetricData"
      ],
      "Resource": "*",
      "Condition": {
        "StringEquals": {
          "cloudwatch:namespace": "RetroGameCloud/Scores"
        }
      }
    }
  ]
}

```

</Tab>
</Tabs>

### Service Accounts de Kubernetes

```yaml

# k8s/rbac/auth-service-account.yml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: auth-service
  namespace: retrogamecloud
  annotations:
    eks.amazonaws.com/role-arn: arn:aws:iam::ACCOUNT:role/RetroGameCloud-AuthService

- --
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  namespace: retrogamecloud
  name: auth-service-role
rules:

- apiGroups: [""]
  resources: ["configmaps", "secrets"]
  verbs: ["get", "list"]

- apiGroups: [""]
  resources: ["pods"]
  verbs: ["get", "list", "watch"]

- --
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: auth-service-binding
  namespace: retrogamecloud
subjects:

- kind: ServiceAccount
  name: auth-service
  namespace: retrogamecloud
roleRef:
  kind: Role
  name: auth-service-role
  apiGroup: rbac.authorization.k8s.io

```

## Seguridad de Red

### Security Groups

<Warning>
Los Security Groups actúan como firewall a nivel de instancia. Es crucial mantener las reglas restrictivas.
</Warning>

#### EKS Cluster Security Groups

```yaml

# terraform/security-groups.tf
resource "aws_security_group" "eks_cluster" {
  name_prefix = "retrogamecloud-eks-cluster-"
  vpc_id      = var.vpc_id

  ingress {
    description = "HTTPS from ALB"
    from_port   = 443
    to_port     = 443
    protocol    = "tcp"
    security_groups = [aws_security_group.alb.id]
  }

  ingress {
    description = "Kong Admin API (internal only)"
    from_port   = 8001
    to_port     = 8001
    protocol    = "tcp"
    cidr_blocks = [var.vpc_cidr]
  }

  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }

  tags = {
    Name = "retrogamecloud-eks-cluster"
    Environment = var.environment
  }
}

resource "aws_security_group" "rds" {
  name_prefix = "retrogamecloud-rds-"
  vpc_id      = var.vpc_id

  ingress {
    description = "PostgreSQL from EKS"
    from_port   = 5432
    to_port     = 5432
    protocol    = "tcp"
    security_groups = [aws_security_group.eks_cluster.id]
  }

  tags = {
    Name = "retrogamecloud-rds"
    Environment = var.environment
  }
}

```

#### Application Load Balancer Security Groups

```yaml
resource "aws_security_group" "alb" {
  name_prefix = "retrogamecloud-alb-"
  vpc_id      = var.vpc_id

  ingress {
    description = "HTTP from internet"
    from_port   = 80
    to_port     = 80
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }

  ingress {
    description = "HTTPS from internet"
    from_port   = 443
    to_port     = 443
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }

  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }

  tags = {
    Name = "retrogamecloud-alb"
    Environment = var.environment
  }
}

```

### Network ACLs

```yaml

# terraform/network-acls.tf
resource "aws_network_acl" "private_subnets" {
  vpc_id     = var.vpc_id
  subnet_ids = var.private_subnet_ids

  # Permitir tráfico interno VPC
  ingress {
    protocol   = "tcp"
    rule_no    = 100
    action     = "allow"
    cidr_block = var.vpc_cidr
    from_port  = 0
    to_port    = 65535
  }

  # Permitir respuestas de internet para actualizaciones
  ingress {
    protocol   = "tcp"
    rule_no    = 110
    action     = "allow"
    cidr_block = "0.0.0.0/0"
    from_port  = 1024
    to_port    = 65535
  }

  # Denegar todo el resto
  ingress {
    protocol   = "-1"
    rule_no    = 200
    action     = "deny"
    cidr_block = "0.0.0.0/0"
  }

  egress {
    protocol   = "-1"
    rule_no    = 100
    action     = "allow"
    cidr_block = "0.0.0.0/0"
  }

  tags = {
    Name = "retrogamecloud-private-nacl"
    Environment = var.environment
  }
}

```

## Cifrado

### Cifrado en Tránsito

#### Configuración TLS/SSL

<Tabs>
<Tab title="ALB HTTPS">

```yaml

# k8s/ingress/https-ingress.yml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: retrogamecloud-ingress
  annotations:
    alb.ingress.kubernetes.io/scheme: internet-facing
    alb.ingress.kubernetes.io/target-type: ip
    alb.ingress.kubernetes.io/ssl-policy: ELBSecurityPolicy-TLS-1-2-2019-07
    alb.ingress.kubernetes.io/certificate-arn: arn:aws:acm:eu-west-1:ACCOUNT:certificate/CERT-ID
    alb.ingress.kubernetes.io/ssl-redirect: '443'
spec:
  ingressClassName: alb
  tls:
  - hosts:
    - api.retrogamecloud.com
    - app.retrogamecloud.com
  rules:
  - host: api.retrogamecloud.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: kong-gateway
            port:
              number: 8000

```

</Tab>

<Tab title="Kong TLS">

```yaml

# kong/config/tls-config.yml
apiVersion: v1
kind: ConfigMap
metadata:
  name: kong-tls-config
data:
  kong.conf: |
    ssl_cert = /etc/ssl/certs/kong.crt
    ssl_cert_key = /etc/ssl/private/kong.key
    ssl_protocols = TLSv1.2 TLSv1.3
    ssl_ciphers = ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384
    ssl_prefer_server_ciphers = on

```

</Tab>

<Tab title="PostgreSQL TLS">

```yaml
# RDS Parameter Group con TLS
resource "aws_db_parameter_group" "postgres_tls" {
  name   = "retrogame-postgres-tls"
  family = "postgres15"

  parameter {
    name  = "rds.force_ssl"
    value = "1"
  }

  parameter {
    name  = "ssl_min_protocol_version"
    value = "TLSv1.2"
  }
}

# Connection string con SSL
DATABASE_URL=postgresql://user:pass@db.retrogame.com:5432/retrogame?sslmode=require&sslrootcert=/path/to/rds-ca-bundle.pem
```

</Tab>
</Tabs>
