---
title: 4.1 Seguridad y Gestión de Secretos
description: Guía completa sobre gestión de secretos, políticas de seguridad y mejores
  prácticas para RetroGameCloud
icon: shield-check
---

## 4.1 Introducción

La seguridad en RetroGameCloud es fundamental para proteger los datos de usuarios, mantener la integridad de la plataforma y garantizar el cumplimiento normativo. Esta documentación cubre la gestión de secretos, políticas de seguridad y mejores prácticas implementadas en nuestra arquitectura de microservicios.

<Note>
Todos los secretos y credenciales deben seguir el principio de menor privilegio y rotarse regularmente según las políticas establecidas.
</Note>

## 4.1.1 Gestión de Secretos

### AWS Secrets Manager

Utilizamos AWS Secrets Manager como solución principal para la gestión de secretos críticos de la aplicación.

#### Secretos Almacenados

<Tabs>
<Tab title="Base de Datos">

```json
{
  "secret_name": "retrogamecloud/postgres/main",
  "description": "Credenciales principales de PostgreSQL",
  "secret_value": {
    "username": "rgc_admin",
    "password": "AUTO_GENERATED",
    "host": "rgc-postgres.cluster-xyz.eu-west-1.rds.amazonaws.com",
    "port": 5432,
    "database": "retrogamecloud"
  }
}
```

</Tab>

<Tab title="JWT Secrets">

```json
{
  "secret_name": "retrogamecloud/jwt/tokens",
  "description": "Secretos para firma de tokens JWT",
  "secret_value": {
    "access_token_secret": "AUTO_GENERATED_256_BIT",
    "refresh_token_secret": "AUTO_GENERATED_256_BIT",
    "token_expiry": "15m",
    "refresh_expiry": "7d"
  }
}
```

</Tab>

<Tab title="OAuth2">

```json
{
  "secret_name": "retrogamecloud/oauth2/providers",
  "description": "Credenciales OAuth2 para proveedores externos",
  "secret_value": {
    "google_client_id": "GOOGLE_CLIENT_ID",
    "google_client_secret": "GOOGLE_CLIENT_SECRET",
    "discord_client_id": "DISCORD_CLIENT_ID",
    "discord_client_secret": "DISCORD_CLIENT_SECRET"
  }
}
```

</Tab>
</Tabs>

### 4.1.2 Configuración de Rotación Automática

```yaml
# terraform/secrets-rotation.tf
resource "aws_secretsmanager_rotation_configuration" "db_rotation" {
  secret_id           = aws_secretsmanager_secret.db_credentials.id
  rotation_lambda_arn = aws_lambda_function.secrets_rotation.arn
  
  rotation_rules {
    automatically_after_days = 30
  }
}

resource "aws_lambda_function" "secrets_rotation" {
  filename         = "rotation-lambda.zip"
  function_name    = "retrogamecloud-secrets-rotation"
  role            = aws_iam_role.rotation_role.arn
  handler         = "index.handler"
  runtime         = "python3.9"
  
  environment {
    variables = {
      SECRETS_MANAGER_ENDPOINT = "https://secretsmanager.${var.region}.amazonaws.com"
    }
  }
}
```

## 4.1.3 Kubernetes Secrets

Para los secretos a nivel de aplicación, utilizamos Kubernetes Secrets sincronizados con AWS Secrets Manager mediante External Secrets Operator.

### External Secrets Operator

```yaml
# k8s/external-secrets/secret-store.yaml
apiVersion: external-secrets.io/v1beta1
kind: SecretStore
metadata:
  name: aws-secrets-manager
  namespace: retrogamecloud
spec:
  provider:
    aws:
      service: SecretsManager
      region: eu-west-1
      auth:
        secretRef:
          accessKeyIDSecretRef:
            name: awssm-secret
            key: access-key
          secretAccessKeySecretRef:
            name: awssm-secret
            key: secret-access-key
```

### External Secret Configuration

```yaml
# k8s/external-secrets/database-secret.yaml
apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  name: postgres-credentials
  namespace: retrogamecloud
spec:
  refreshInterval: 1h
  secretStoreRef:
    name: aws-secrets-manager
    kind: SecretStore
  target:
    name: postgres-secret
    creationPolicy: Owner
  data:
  - secretKey: username
    remoteRef:
      key: retrogamecloud/postgres/main
      property: username
  - secretKey: password
    remoteRef:
      key: retrogamecloud/postgres/main
      property: password
  - secretKey: host
    remoteRef:
      key: retrogamecloud/postgres/main
      property: host
```

## 4.1.4 Políticas de Seguridad

### Política de Contraseñas

<Steps>

<Step title="Complejidad Mínima">
- Mínimo 12 caracteres
- Combinación de mayúsculas, minúsculas, números y símbolos
- No debe contener información personal
- Verificación contra diccionarios de contraseñas comprometidas
</Step>

<Step title="Rotación Obligatoria">
- Credenciales de servicio: cada 30 días
- Credenciales de administrador: cada 60 días
- Tokens de API: cada 7 días
- Certificados: cada 90 días
</Step>

<Step title="Almacenamiento Seguro">
- Nunca almacenar en texto plano
- Uso obligatorio de hashing con sal (bcrypt, scrypt, Argon2)
- Cifrado en tránsito y en reposo
</Step>

</Steps>

### Configuración de Hashing

```typescript
// src/auth/password-service.ts
import bcrypt from 'bcrypt';
import { promisify } from 'util';

export class PasswordService {
  private static readonly SALT_ROUNDS = 12;
  
  static async hashPassword(plainPassword: string): Promise<string> {
    return await bcrypt.hash(plainPassword, this.SALT_ROUNDS);
  }
  
  static async verifyPassword(
    plainPassword: string, 
    hashedPassword: string
  ): Promise<boolean> {
    return await bcrypt.compare(plainPassword, hashedPassword);
  }
  
  static validatePasswordStrength(password: string): boolean {
    const minLength = 12;
    const hasUpperCase = /[A-Z]/.test(password);
    const hasLowerCase = /[a-z]/.test(password);
    const hasNumbers = /\d/.test(password);
    const hasSpecialChar = /[!@#$%^&*(),.?":{}|<>]/.test(password);
    
    return password.length >= minLength && 
           hasUpperCase && 
           hasLowerCase && 
           hasNumbers && 
           hasSpecialChar;
  }
}
```

## 4.1.5 Autenticación y Autorización

### JWT Configuration

```typescript
// src/auth/jwt-service.ts
import jwt from 'jsonwebtoken';
import { SecretsManager } from '../infrastructure/secrets-manager';

export class JWTService {
  private static secretsManager = new SecretsManager();
  
  static async generateAccessToken(payload: any): Promise<string> {
    const secrets = await this.secretsManager.getSecret('retrogamecloud/jwt/tokens');
    
    return jwt.sign(payload, secrets.access_token_secret, {
      expiresIn: secrets.token_expiry,
      issuer: 'retrogamecloud-api',
      audience: 'retrogamecloud-client',
      algorithm: 'HS256'
    });
  }
  
  static async generateRefreshToken(userId: string): Promise<string> {
    const secrets = await this.secretsManager.getSecret('retrogamecloud/jwt/tokens');
    
    return jwt.sign({ userId }, secrets.refresh_token_secret, {
      expiresIn: secrets.refresh_expiry,
      issuer: 'retrogamecloud-api',
      algorithm: 'HS256'
    });
  }
  
  static async verifyToken(token: string, type: 'access' | 'refresh'): Promise<any> {
    const secrets = await this.secretsManager.getSecret('retrogamecloud/jwt/tokens');
    const secret = type === 'access' ? 
      secrets.access_token_secret : 
      secrets.refresh_token_secret;
    
    return jwt.verify(token, secret);
  }
}
```

### Role-Based Access Control (RBAC)

```typescript
// src/auth/rbac.ts
export enum Permission {
  // User permissions
  USER_READ = 'user:read',
  USER_WRITE = 'user:write',
  USER_DELETE = 'user:delete',
  
  // Game permissions
  GAME_READ = 'game:read',
  GAME_WRITE = 'game:write',
  GAME_DELETE = 'game:delete',
  GAME_UPLOAD = 'game:upload',
  
  // Save permissions
  SAVE_READ = 'save:read',
  SAVE_WRITE = 'save:write',
  SAVE_DELETE = 'save:delete',
  
  // Admin permissions
  ADMIN_USERS = 'admin:users',
  ADMIN_GAMES = 'admin:games',
  ADMIN_SYSTEM = 'admin:system'
}

export enum Role {
  GUEST = 'guest',
  USER = 'user',
  PREMIUM = 'premium',
  MODERATOR = 'moderator',
  ADMIN = 'admin'
}

export const rolePermissions: Record<Role, Permission[]> = {
  [Role.GUEST]: [
    Permission.GAME_READ
  ],
  [Role.USER]: [
    Permission.USER_READ,
    Permission.USER_WRITE,
    Permission.GAME_READ,
    Permission.SAVE_READ,
    Permission.SAVE_WRITE,
    Permission.SAVE_DELETE
  ],
  [Role.PREMIUM]: [
    ...rolePermissions[Role.USER],
    Permission.GAME_UPLOAD
  ],
  [Role.MODERATOR]: [
    ...rolePermissions[Role.PREMIUM],
    Permission.GAME_WRITE,
    Permission.USER_DELETE
  ],
  [Role.ADMIN]: [
    ...Object.values(Permission)
  ]
};
```

## 4.1.6 Cifrado de Datos

### Cifrado en Tránsito

<Tabs>
<Tab title="HTTPS/TLS">

```yaml
# k8s/ingress/tls-ingress.yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: retrogamecloud-ingress
  annotations:
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
    nginx.ingress.kubernetes.io/force-ssl-redirect: "true"
    cert-manager.io/cluster-issuer: "letsencrypt-prod"
spec:
  tls:
  - hosts:
    - api.retrogamecloud.com
    - app.retrogamecloud.com
    secretName: retrogamecloud-tls
  rules:
  - host: api.retrogamecloud.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: api-service
            port:
              number: 3000
```

</Tab>

<Tab title="Database Encryption">

```typescript
// src/database/connection.ts
import { DataSource } from 'typeorm';

export const AppDataSource = new DataSource({
  type: 'postgres',
  host: process.env.DB_HOST,
  port: parseInt(process.env.DB_PORT || '5432'),
  username: process.env.DB_USERNAME,
  password: process.env.DB_PASSWORD,
  database: process.env.DB_NAME,
  ssl: {
    require: true,
    rejectUnauthorized: true,
    ca: process.env.DB_CA_CERT
  },
  extra: {
    ssl: {
      sslmode: 'require'
    }
  }
});
```

</Tab>
</Tabs>

### Cifrado en Reposo

```typescript
// src/utils/encryption.ts
import crypto from 'crypto';
import { SecretsManager } from '../infrastructure/secrets-manager';

export class EncryptionService {
  private static algorithm = 'aes-256-gcm';
  private static secretsManager = new SecretsManager();
  
  static async encryptData(data: string): Promise<{
    encrypted: string;
    iv: string;
    tag: string;
  }> {
    const secrets = await this.secretsManager.getSecret('retrogamecloud/encryption/key');
    const key = Buffer.from(secrets.encryption_key, 'hex');
    const iv = crypto.randomBytes(16);
    
    const cipher = crypto.createCipher(this.algorithm, key);
    cipher.setAAD(Buffer.from('retrogamecloud', 'utf8'));
    
    let encrypted = cipher.update(data, 'utf8', 'hex');
    encrypted += cipher.final('hex');
    
    const tag = cipher.getAuthTag();
    
    return {
      encrypted,
      iv: iv.toString('hex'),
      tag: tag.toString('hex')
    };
  }
  
  static async decryptData(encryptedData: {
    encrypted: string;
    iv: string;
    tag: string;
  }): Promise<string> {
    const secrets = await this.secretsManager.getSecret('retrogamecloud/encryption/key');
    const key = Buffer.from(secrets.encryption_key, 'hex');
    
    const decipher = crypto.createDecipher(this.algorithm, key);
    decipher.setAuthTag(Buffer.from(encryptedData.tag, 'hex'));
    decipher.setAAD(Buffer.from('retrogamecloud', 'utf8'));
    
    let decrypted = decipher.update(encryptedData.encrypted, 'hex', 'utf8');
    decrypted += decipher.final('utf8');
    
    return decrypted;
  }
}
```

## 4.1.7 Auditoría y Logging

### Security Event Logging

```typescript
// src/logging/security-logger.ts
import { Logger } from 'winston';
import { SecurityEvent } from './types';

export class SecurityLogger {
  private logger: Logger;
  
  constructor(logger: Logger) {
    this.logger = logger;
  }
  
  logAuthenticationAttempt(event: {
    userId?: string;
    email: string;
    success: boolean;
    ipAddress: string;
    userAgent: string;
    timestamp: Date;
  }) {
    this.logger.info('Authentication Attempt', {
      event_type: 'auth_attempt',
      user_id: event.userId,
      email: event.email,
      success: event.success,
      ip_address: event.ipAddress,
      user_agent: event.userAgent,
      timestamp: event.timestamp
    });
  }
  
  logPermissionDenied(event: {
    userId: string;
    resource: string;
    action: string;
    ipAddress: string;
    timestamp: Date;
  }) {
    this.logger.warn('Permission Denied', {
      event_type: 'permission_denied',
      user_id:
```