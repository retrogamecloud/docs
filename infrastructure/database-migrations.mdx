---
title: 6.8. Migraciones de Base de Datos
description: Gu√≠a completa para ejecutar migraciones de esquema en RDS PostgreSQL
  de forma segura, con estrategias de versionado, procedimientos de rollback y despliegues
  sin downtime
icon: database
---

## Introducci√≥n

Las migraciones de base de datos en RetroGameCloud requieren un enfoque estructurado para mantener la integridad de datos y minimizar el tiempo de inactividad. Esta gu√≠a cubre desde la creaci√≥n de scripts hasta la ejecuci√≥n en producci√≥n con estrategias de zero-downtime.

<Note>
Todas las migraciones deben probarse exhaustivamente en entornos locales y staging antes del despliegue en producci√≥n.
</Note>

## Herramientas de Migraci√≥n

### Flyway
Utilizamos **Flyway** como herramienta principal para el versionado y ejecuci√≥n de migraciones de esquema:

- Versionado autom√°tico de scripts SQL

- Seguimiento del estado de migraciones

- Validaci√≥n de checksums

- Soporte para rollbacks

### Configuraci√≥n Docker
Para desarrollo local, utilizamos un contenedor Flyway configurado:

```yaml
version: '3.8'
services:
  flyway:
    image: flyway/flyway:8.5.13
    command: -url=jdbc:postgresql://postgres:5432/retrogame -user=postgres -password=password -connectRetries=60 migrate
    volumes:
      - ./migrations:/flyway/sql
    depends_on:
      - postgres
    environment:
      - FLYWAY_BASELINE_ON_MIGRATE=true
      - FLYWAY_VALIDATE_ON_MIGRATE=true

```

### Configuraci√≥n AWS RDS
Para producci√≥n en AWS RDS PostgreSQL:

```yaml
flyway:
  environment: production
  url: jdbc:postgresql://retrogame-prod.cluster-xxx.us-west-2.rds.amazonaws.com:5432/retrogame
  user: ${AWS_RDS_USERNAME}
  password: ${AWS_RDS_PASSWORD}
  schemas: public,game_data,user_profiles
  locations: filesystem:./migrations/schema,filesystem:./migrations/data
  baseline-on-migrate: false
  validate-on-migrate: true
  out-of-order: false
  mixed: false

```

## Estructura de Migraciones

### Convenci√≥n de Nomenclatura

Las migraciones siguen una estructura estricta:

<Tabs>
<Tab title="Migraciones hacia adelante">

```

V{version}__{descripci√≥n}.sql

Ejemplos:

- V001__initial_schema.sql

- V002__add_user_achievements.sql

- V003__create_game_scores_index.sql

```

</Tab>
<Tab title="Migraciones de rollback">

```

U{version}__{descripci√≥n}.sql

Ejemplos:

- U002__remove_user_achievements.sql

- U003__drop_game_scores_index.sql

```

</Tab>
</Tabs>

### Estructura de Directorios

```

migrations/
‚îú‚îÄ‚îÄ schema/
‚îÇ   ‚îú‚îÄ‚îÄ V001__initial_schema.sql
‚îÇ   ‚îú‚îÄ‚îÄ V002__add_user_achievements.sql
‚îÇ   ‚îú‚îÄ‚îÄ V003__create_game_scores_index.sql
‚îÇ   ‚îî‚îÄ‚îÄ rollback/
‚îÇ       ‚îú‚îÄ‚îÄ U002__remove_user_achievements.sql
‚îÇ       ‚îî‚îÄ‚îÄ U003__drop_game_scores_index.sql
‚îú‚îÄ‚îÄ data/
‚îÇ   ‚îú‚îÄ‚îÄ R001__seed_game_categories.sql
‚îÇ   ‚îú‚îÄ‚îÄ R002__load_retro_games_catalog.sql
‚îÇ   ‚îî‚îÄ‚îÄ R003__default_user_preferences.sql
‚îú‚îÄ‚îÄ functions/
‚îÇ   ‚îú‚îÄ‚îÄ V010__calculate_user_score.sql
‚îÇ   ‚îî‚îÄ‚îÄ V011__game_recommendation_engine.sql
‚îî‚îÄ‚îÄ procedures/
    ‚îú‚îÄ‚îÄ V020__backup_user_progress.sql
    ‚îî‚îÄ‚îÄ V021__cleanup_expired_sessions.sql

```

## Tipos de Migraciones

### Migraciones de Esquema

<Tabs>
<Tab title="Crear Tabla">

```sql

- - V001__create_users_table.sql
CREATE TABLE IF NOT EXISTS users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    is_active BOOLEAN DEFAULT true,
    metadata JSONB DEFAULT '{}'
);

CREATE INDEX idx_users_username ON users(username);
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_created_at ON users(created_at);

- - Trigger para updated_at
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TRIGGER update_users_updated_at
    BEFORE UPDATE ON users
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

```

</Tab>
<Tab title="Agregar Columna">

```sql

- - V005__add_user_level_column.sql
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns
        WHERE table_name = 'users' AND column_name = 'level'
    ) THEN
        ALTER TABLE users ADD COLUMN level INTEGER DEFAULT 1 CHECK (level >= 1 AND level <= 100);
        CREATE INDEX idx_users_level ON users(level) WHERE level > 1;
    END IF;
END
$$;

- - Comentario para documentaci√≥n
COMMENT ON COLUMN users.level IS 'Nivel del usuario basado en experiencia acumulada (1-100)';

```

</Tab>
<Tab title="Crear √çndice">

```sql

- - V008__create_game_performance_indexes.sql

- - √çndices para optimizar consultas de rendimiento de juegos
CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_game_sessions_user_game
    ON game_sessions(user_id, game_id)
    WHERE ended_at IS NOT NULL;

CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_game_sessions_duration
    ON game_sessions(duration)
    WHERE duration > INTERVAL '1 minute';

CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_user_scores_composite
    ON user_scores(game_id, score DESC, created_at DESC);

- - Estad√≠sticas para el optimizador
ANALYZE game_sessions;
ANALYZE user_scores;

```

</Tab>
</Tabs>

### Migraciones de Datos

<Tabs>
<Tab title="Seed Data">

```sql

- - R001__seed_game_categories.sql
INSERT INTO game_categories (name, slug, description, icon, sort_order) VALUES
    ('Arcade', 'arcade', 'Juegos cl√°sicos de arcade', 'joystick', 1),
    ('Puzzle', 'puzzle', 'Juegos de l√≥gica y rompecabezas', 'puzzle-piece', 2),
    ('Platformer', 'platformer', 'Juegos de plataformas', 'running', 3),
    ('RPG', 'rpg', 'Juegos de rol cl√°sicos', 'dragon', 4),
    ('Shooter', 'shooter', 'Juegos de disparos retro', 'crosshairs', 5)
ON CONFLICT (slug) DO UPDATE SET
    name = EXCLUDED.name,
    description = EXCLUDED.description,
    icon = EXCLUDED.icon,
    updated_at = NOW();

```

</Tab>
<Tab title="Data Migration">

```sql

- - V015__migrate_user_preferences.sql

- - Migrar preferencias de usuario del formato legacy al nuevo esquema

DO $$
DECLARE
    user_record RECORD;
    new_preferences JSONB;
BEGIN
    FOR user_record IN
        SELECT id, legacy_preferences
        FROM users
        WHERE legacy_preferences IS NOT NULL
        AND preferences IS NULL
    LOOP
        -- Convertir formato legacy a nuevo esquema
        new_preferences := jsonb_build_object(
            'graphics', jsonb_build_object(
                'quality', COALESCE(user_record.legacy_preferences->>'graphics_quality', 'medium'),
                'fullscreen', COALESCE((user_record.legacy_preferences->>'fullscreen')::boolean, false)
            ),
            'audio', jsonb_build_object(
                'master_volume', COALESCE((user_record.legacy_preferences->>'volume')::float, 0.8),
                'sfx_enabled', COALESCE((user_record.legacy_preferences->>'sound_effects')::boolean, true),
                'music_enabled', COALESCE((user_record.legacy_preferences->>'background_music')::boolean, true)
            ),
            'controls', jsonb_build_object(
                'keyboard_layout', COALESCE(user_record.legacy_preferences->>'keyboard', 'qwerty'),
                'gamepad_enabled', COALESCE((user_record.legacy_preferences->>'gamepad')::boolean, true)
            )
        );

        UPDATE users
        SET preferences = new_preferences,
            updated_at = NOW()
        WHERE id = user_record.id;
    END LOOP;

    RAISE NOTICE 'Migradas preferencias para % usuarios',
        (SELECT COUNT(*) FROM users WHERE preferences IS NOT NULL AND legacy_preferences IS NOT NULL);
END
$$;

```

</Tab>
</Tabs>

## Estrategias de Despliegue

### Zero-Downtime Deployments

#### Estrategia de Compatibilidad Backwards/Forwards

<Tabs>
<Tab title="Fase 1: Preparaci√≥n">

```sql

- - V020__prepare_user_avatar_migration.sql

- - Agregar nueva columna sin eliminar la antigua
ALTER TABLE users ADD COLUMN avatar_url_v2 TEXT;
ALTER TABLE users ADD COLUMN avatar_metadata JSONB DEFAULT '{}';

- - Crear √≠ndice para nueva columna
CREATE INDEX CONCURRENTLY idx_users_avatar_v2 ON users(avatar_url_v2)
WHERE avatar_url_v2 IS NOT NULL;

- - Funci√≥n para migraci√≥n gradual
CREATE OR REPLACE FUNCTION migrate_user_avatar(user_uuid UUID)
RETURNS BOOLEAN AS $$
DECLARE
    old_avatar TEXT;
    new_avatar TEXT;
    metadata JSONB;
BEGIN
    SELECT avatar_url INTO old_avatar FROM users WHERE id = user_uuid;

    IF old_avatar IS NOT NULL AND old_avatar != '' THEN
        -- Convertir URL antigua al nuevo formato
        new_avatar := 'https://cdn.retrogamecloud.com/avatars/' ||
                     encode(digest(old_avatar, 'sha256'), 'hex') || '.webp';

        metadata := jsonb_build_object(
            'original_url', old_avatar,
            'format', 'webp',
            'migrated_at', NOW()
        );

        UPDATE users
        SET avatar_url_v2 = new_avatar,
            avatar_metadata = metadata,
            updated_at = NOW()
        WHERE id = user_uuid;

        RETURN TRUE;
    END IF;

    RETURN FALSE;
END;
$$ LANGUAGE plpgsql;

```

</Tab>
<Tab title="Fase 2: Migraci√≥n">

```sql

- - V021__execute_user_avatar_migration.sql

- - Ejecutar migraci√≥n en lotes para evitar locks largos

DO $$
DECLARE
    batch_size INTEGER := 1000;
    processed INTEGER := 0;
    total_users INTEGER;
    user_batch UUID[];
BEGIN
    SELECT COUNT(*) INTO total_users FROM users WHERE avatar_url IS NOT NULL;
    RAISE NOTICE 'Iniciando migraci√≥n de % avatares de usuario', total_users;

    WHILE processed < total_users LOOP
        -- Procesar en lotes
        SELECT ARRAY_AGG(id) INTO user_batch
        FROM (
            SELECT id FROM users
            WHERE avatar_url IS NOT NULL
            AND avatar_url_v2 IS NULL
            LIMIT batch_size
        ) batch;

        -- Si no hay m√°s registros, salir
        IF user_batch IS NULL OR array_length(user_batch, 1) = 0 THEN
            EXIT;
        END IF;

        -- Migrar lote actual
        PERFORM migrate_user_avatar(user_id) FROM unnest(user_batch) AS user_id;

        processed := processed + array_length(user_batch, 1);

        RAISE NOTICE 'Procesados % de % avatares (%.2f%%)',
            processed, total_users, (processed::float / total_users * 100);

        -- Pausa para evitar saturar la base de datos
        PERFORM pg_sleep(0.1);
    END LOOP;

    RAISE NOTICE 'Migraci√≥n completada: % avatares procesados', processed;
END
$$;

```

</Tab>
<Tab title="Fase 3: Limpieza">

```sql

- - V022__cleanup_user_avatar_migration.sql

- - Solo ejecutar despu√©s de verificar que la aplicaci√≥n funciona correctamente

- - Verificar que la migraci√≥n fue exitosa
DO $$
DECLARE
    unmigrated_count INTEGER;
BEGIN
    SELECT COUNT(*) INTO unmigrated_count
    FROM users
    WHERE avatar_url IS NOT NULL AND avatar_url_v2 IS NULL;

    IF unmigrated_count > 0 THEN
        RAISE EXCEPTION 'A√∫n hay % usuarios sin migrar. Abortar limpieza.', unmigrated_count;
    END IF;

    RAISE NOTICE 'Verificaci√≥n exitosa. Procediendo con limpieza.';
END
$$;

- - Renombrar columnas
ALTER TABLE users RENAME COLUMN avatar_url TO avatar_url_legacy;
ALTER TABLE users RENAME COLUMN avatar_url_v2 TO avatar_url;

- - Crear vista temporal para compatibilidad durante transici√≥n
CREATE OR REPLACE VIEW users_with_legacy_avatar AS
SELECT
    id,
    username,
    email,
    avatar_url,
    avatar_url_legacy,
    created_at,
    updated_at,
    is_active
FROM users;

- - Programar eliminaci√≥n de columna legacy (ejecutar en pr√≥ximo release)

- - ALTER TABLE users DROP COLUMN avatar_url_legacy;

```

</Tab>
</Tabs>

### Blue-Green Deployments

Para cambios cr√≠ticos que requieren validaci√≥n completa:

```sql

- - V025__create_blue_green_switch.sql

- - Sistema de switch para despliegues blue-green

CREATE TABLE IF NOT EXISTS deployment_config (
    key VARCHAR(50) PRIMARY KEY,
    value TEXT NOT NULL,
    environment VARCHAR(20) NOT NULL DEFAULT 'production',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

- - Configuraci√≥n inicial
INSERT INTO deployment_config (key, value, environment) VALUES
    ('database_version', 'blue', 'production'),
    ('schema_compatibility', 'v1.0', 'production'),
    ('feature_flags', '{"new_scoring_system": false}', 'production')
ON CONFLICT (key) DO NOTHING;

- - Funci√≥n para cambiar entre entornos
CREATE OR REPLACE FUNCTION switch_deployment_environment(
    target_env TEXT DEFAULT 'green'
) RETURNS TABLE(key TEXT, old_value TEXT, new_value TEXT) AS $$
BEGIN
    RETURN QUERY
    WITH updates AS (
        UPDATE deployment_config
        SET value = CASE
            WHEN value = 'blue' THEN 'green'
            WHEN value = 'green' THEN 'blue'
            ELSE target_env
        END,
        updated_at = NOW()
        WHERE key IN ('database_version', 'active_environment')
        RETURNING key, value
    )
    SELECT u.key::TEXT, 'switched'::TEXT, u.value::TEXT FROM updates u;
END;
$$ LANGUAGE plpgsql;

```

## Procedimientos de Rollback

### Rollback Autom√°tico

<Tabs>
<Tab title="Script de Rollback">

```sql

- - U010__rollback_user_achievements.sql

- - Rollback para V010__add_user_achievements.sql

DO $$
BEGIN
    -- Verificar si existen dependencias
    IF EXISTS (
        SELECT 1 FROM information_schema.table_constraints
        WHERE constraint_name LIKE '%achievements%'
        AND constraint_type = 'FOREIGN KEY'
    ) THEN
        RAISE EXCEPTION 'No se puede hacer rollback: existen dependencias en user_achievements';
    END IF;

    -- Backup de datos antes del rollback
    CREATE TEMP TABLE achievements_backup AS
    SELECT * FROM user_achievements;

    RAISE NOTICE 'Backup creado con % registros',
        (SELECT COUNT(*) FROM achievements_backup);

    -- Eliminar triggers
    DROP TRIGGER IF EXISTS update_user_achievements_updated_at ON user_achievements;

    -- Eliminar √≠ndices
    DROP INDEX IF EXISTS idx_user_achievements_user_id;
    DROP INDEX IF EXISTS idx_user_achievements_achievement_type;
    DROP INDEX IF EXISTS idx_user_achievements_earned_date;

    -- Eliminar tabla
    DROP TABLE IF EXISTS user_achievements CASCADE;

    RAISE NOTICE 'Rollback completado para user_achievements';

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'Error en rollback: %', SQLERRM;
END
$$;

```

</Tab>
<Tab title="Rollback de Datos">

```sql

- - U015__rollback_user_preferences_migration.sql

- - Restaurar formato legacy de preferencias de usuario

DO $$
DECLARE
    affected_count INTEGER := 0;
BEGIN
    -- Restaurar preferencias al formato legacy
    UPDATE users
    SET legacy_preferences = CASE
        WHEN preferences IS NOT NULL THEN
            jsonb_build_object(
                'graphics_quality', preferences->'graphics'->>'quality',
                'fullscreen', preferences->'graphics'->'fullscreen',
                'volume', preferences->'audio'->'master_volume',
                'sound_effects', preferences->'audio'->'sfx_enabled',
                'background_music', preferences->'audio'->'music_enabled',
                'keyboard', preferences->'controls'->>'keyboard_layout',
                'gamepad', preferences->'controls'->'gamepad_enabled'
            )
        ELSE legacy_preferences
    END,
    preferences = NULL,
    updated_at = NOW()
    WHERE preferences IS NOT NULL;

    GET DIAGNOSTICS affected_count = ROW_COUNT;

    RAISE NOTICE 'Rollback completado: % usuarios restaurados al formato legacy',
        affected_count;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'Error en rollback de preferencias: %', SQLERRM;
END
$$;

```

</Tab>
</Tabs>

### Rollback Manual de Emergencia

```bash
#!/bin/bash

# rollback-emergency.sh - Script de rollback de emergencia

set -e

ENVIRONMENT=${1:-staging}
ROLLBACK_VERSION=${2:-""}
DB_BACKUP_PATH=${3:-"/backups/emergency"}

echo "üö® ROLLBACK DE EMERGENCIA - Entorno: $ENVIRONMENT"
echo "üö® Versi√≥n objetivo: $ROLLBACK_VERSION"

# Validaciones de seguridad
if [[ "$ENVIRONMENT" == "production" ]]; then
    echo "‚ö†Ô∏è  ROLLBACK EN PRODUCCI√ìN - Confirmaci√≥n requerida"
    read -p "Escriba 'CONFIRMO ROLLBACK PRODUCCION' para continuar: " confirmation
    if [[ "$confirmation" != "CONFIRMO ROLLBACK PRODUCCION" ]]; then
        echo "‚ùå Rollback cancelado"
        exit 1
    fi
fi

# Crear backup antes del rollback
echo "üì¶ Creando backup de seguridad..."
BACKUP_FILE="$DB_BACKUP_PATH/pre-rollback-$(date +%Y%m%d-%H%M%S).sql"
docker exec postgres pg_dump -U postgres retrogame > "$BACKUP_FILE"
echo "‚úÖ Backup creado: $BACKUP_FILE"

# Ejecutar rollback con Flyway
echo "üîÑ Ejecutando rollback a versi√≥n $ROLLBACK_VERSION..."
docker run --rm \
    --network retrogame_network \
    -v $(pwd)/migrations:/flyway/sql \
    flyway/flyway:8.5.13 \
    -url=jdbc:postgresql://postgres:5432/retrogame \
    -user=postgres \
    -password=password \
    -target=$ROLLBACK_VERSION \
    repair

# Verificar estado
echo "üîç Verificando estado post-rollback..."
docker run --rm \
    --network retrogame_network \
    flyway/flyway:8.5.13 \
    -url=jdbc:postgresql://postgres:5432/retrogame \
    -user=postgres \
    -password=password \
    info

echo "‚úÖ Rollback de emergencia completado"
echo "üìã Backup disponible en: $BACKUP_FILE"

```

## Validaci√≥n y Testing

### Tests de Migraci√≥n

```sql

- - tests/migration_tests.sql

- - Suite de tests para validar migraciones

- - Test 1: Verificar integridad de esquema
CREATE OR REPLACE FUNCTION test_schema_integrity()
RETURNS BOOLEAN AS $$
DECLARE
    missing_tables TEXT[];
    missing_indexes TEXT[];
    result BOOLEAN := TRUE;
BEGIN
    -- Verificar tablas cr√≠ticas
    SELECT ARRAY_AGG(table_name) INTO missing_tables
    FROM (VALUES
        ('users'),
        ('games'),
        ('user_scores'),
        ('game_sessions')
    ) AS required_tables(table_name)
    WHERE table_name NOT IN (
        SELECT table_name
        FROM information_schema.tables
        WHERE table_schema = 'public'
    );

    IF array_length(missing_tables, 1) > 0 THEN
        RAISE WARNING 'Tablas faltantes: %', missing_tables;
        result := FALSE;
    END IF;

    -- Verificar √≠ndices cr√≠ticos
    SELECT ARRAY_AGG(indexname) INTO missing_indexes
    FROM (VALUES
        ('idx_users_email'),
        ('idx_user_scores_composite'),
        ('idx_game_sessions_user_game')
    ) AS required_indexes(indexname)
    WHERE indexname NOT IN (
        SELECT indexname
        FROM pg_indexes
        WHERE schemaname = 'public'
    );

    IF array_length(missing_indexes, 1) > 0 THEN
        RAISE WARNING '√çndices faltantes: %', missing_indexes;
        result := FALSE;
    END IF;

    RETURN result;
END;
$$ LANGUAGE plpgsql;

- - Test 2: Verificar integridad de datos
CREATE OR REPLACE FUNCTION test_data_integrity()
RETURNS BOOLEAN AS $$
DECLARE
    orphaned_scores INTEGER;
    invalid_users INTEGER;
    result BOOLEAN := TRUE;
BEGIN
    -- Verificar scores hu√©rfanos
    SELECT COUNT(*) INTO orphaned_scores
    FROM user_scores us
    LEFT JOIN users u ON us.user_id = u.id
    WHERE u.id IS NULL;

    IF orphaned_scores > 0 THEN
        RAISE WARNING 'Scores hu√©rfanos detectados: %', orphaned_scores;
        result := FALSE;
    END IF;

    -- Verificar usuarios inv√°lidos
    SELECT COUNT(*) INTO invalid_users
    FROM users
    WHERE email IS NULL OR email = ''
    OR username IS NULL OR username = '';

    IF invalid_users > 0 THEN
        RAISE WARNING 'Usuarios con datos inv√°lidos: %', invalid_users;
        result := FALSE;
    END IF;

    RETURN result;
END;
$$ LANGUAGE plpgsql;

- - Test 3: Performance de consultas cr√≠ticas
CREATE OR REPLACE FUNCTION test_query_performance()
RETURNS BOOLEAN AS $$
DECLARE
    start_time TIMESTAMP;
    end_time TIMESTAMP;
    duration INTERVAL;
    result BOOLEAN := TRUE;
BEGIN
    -- Test consulta de leaderboard
    start_time := clock_timestamp();

    PERFORM game_id, user_id, score
    FROM user_scores
    ORDER BY score DESC
    LIMIT 100;

    end_time := clock_timestamp();
    duration := end_time - start_time;

    IF duration > INTERVAL '100 milliseconds' THEN
        RAISE WARNING 'Query de leaderboard lenta: %', duration;
        result := FALSE;
    END IF;

    RETURN result;
END;
$$ LANGUAGE plpgsql;

```

### Validaci√≥n Autom√°tica

```bash
#!/bin/bash

# validate-migration.sh - Script de validaci√≥n post-migraci√≥n

set -e

echo "üîç Iniciando validaci√≥n de migraci√≥n..."

# Ejecutar tests de validaci√≥n
echo "üìä Ejecutando tests de integridad..."
docker exec postgres psql -U postgres -d retrogame -c "
    SELECT
        'Schema Integrity' as test_name,
        test_schema_integrity() as result;

    SELECT
        'Data Integrity' as test_name,
        test_data_integrity() as result;

    SELECT
        'Query Performance' as test_name,
        test_query_performance() as result;
"

# Verificar estado de Flyway
echo "üìã Verificando estado de migraciones..."
docker run --rm \
    --network retrogame_network \
    flyway/flyway:8.5.13 \
    -url=jdbc:postgresql://postgres:5432/retrogame \
    -user=postgres \
    -password=password \
    info

# Verificar m√©tricas de rendimiento
echo "‚ö° Verificando m√©tricas de rendimiento..."
docker exec postgres psql -U postgres -d retrogame -c "
    SELECT
        schemaname,
        tablename,
        n_tup_ins as inserts,
        n_tup_upd as updates,
        n_tup_del as deletes,
        seq_scan,
        seq_tup_read,
        idx_scan,
        idx_tup_fetch
    FROM pg_stat_user_tables
    WHERE schemaname = 'public'
    ORDER BY tablename;
"

echo "‚úÖ Validaci√≥n completada"

```

## Monitoreo y Alertas

### M√©tricas de Migraci√≥n

```sql

- - monitoring/migration_metrics.sql

- - Vistas para monitoreo de migraciones

CREATE OR REPLACE VIEW migration_status AS
SELECT
    installed_rank,
    version,
    description,
    type,
    script,
    installed_by,
    installed_on,
    execution_time,
    success
FROM flyway_schema_history
ORDER BY installed_rank DESC;

CREATE OR REPLACE VIEW database_health_check AS
SELECT
    'Tables' as metric_type,
    COUNT(*)::TEXT as value
FROM information_schema.tables
WHERE table_schema = 'public'

UNION ALL

SELECT
    'Indexes' as metric_type,
    COUNT(*)::TEXT as value
FROM pg_indexes
WHERE schemaname = 'public'

UNION ALL

SELECT
    'Functions' as metric_type,
    COUNT(*)::TEXT as value
FROM information_schema.routines
WHERE routine_schema = 'public'

UNION ALL

SELECT
    'Database Size' as metric_type,
    pg_size_pretty(pg_database_size(current_database())) as value;

```

### Alertas CloudWatch

```yaml

# cloudwatch-migration-alarms.yml
AWSTemplateFormatVersion: '2010-09-09'
Description: 'CloudWatch alarms para migraciones de base de datos'

Resources:
  MigrationFailureAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName: 'RetroGame-DB-Migration-Failure'
      AlarmDescription: 'Alerta cuando fallan las migraciones de base de datos'
      MetricName: 'MigrationFailures'
      Namespace: 'RetroGameCloud/Database'
      Statistic: Sum
      Period: 300
      EvaluationPeriods: 1
      Threshold: 1
      ComparisonOperator: GreaterThanOrEqualToThreshold
      AlarmActions:
        - !Ref SNSTopicArn
        - !Ref SlackWebhookLambda

  DatabaseConnectionAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName: 'RetroGame-DB-Connection-Issues'
      AlarmDescription: 'Alerta por problemas de conexi√≥n durante migraciones'
      MetricName: 'DatabaseConnections'
      Namespace: 'AWS/RDS'
      Statistic: Average
      Period: 60
      EvaluationPeriods: 2
      Threshold: 80
      ComparisonOperator: GreaterThanThreshold
      Dimensions:
        - Name: DBInstanceIdentifier
          Value: retrogame-production

  LongRunningMigrationAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName: 'RetroGame-Long-Running-Migration'
      AlarmDescription: 'Alerta por migraciones que tardan demasiado'
      MetricName: 'MigrationDuration'
      Namespace: 'RetroGameCloud/Database'
      Statistic: Maximum
      Period: 300
      EvaluationPeriods: 1
      Threshold: 600  # 10 minutos
      ComparisonOperator: GreaterThanThreshold

```

<Warning>
Las migraciones de producci√≥n siempre deben ser ejecutadas durante ventanas de mantenimiento programadas y con equipos de respaldo disponibles.
</Warning>

## Mejores Pr√°cticas

### Checklist Pre-Migraci√≥n

- [ ] **Backup completo** de la base de datos

- [ ] **Tests exhaustivos** en staging

- [ ] **Validaci√≥n de rollback** preparada

- [ ] **Ventana de mantenimiento** programada

- [ ] **Equipo de respaldo** disponible

- [ ] **Monitoreo activo** configurado

- [ ] **Comunicaci√≥n stakeholders** enviada

### Durante la Migraci√≥n

- [ ] **Logs en tiempo real** activos

- [ ] **M√©tricas de performance** monitoreadas

- [ ] **Rollback plan** listo para ejecutar

- [ ] **Status updates** regulares

- [ ] **Health checks** funcionando

### Post-Migraci√≥n

- [ ] **Validaci√≥n completa** ejecutada

- [ ] **Performance testing** completado

- [ ] **Cleanup de temporales** realizado

- [ ] **Documentaci√≥n** actualizada

- [ ] **Lessons learned** documentadas

Esta gu√≠a consolidada proporciona un framework completo para manejar migraciones de base de datos de forma segura y eficiente en RetroGameCloud, desde el desarrollo hasta producci√≥n.