{
  "analysis_summary": "Documentación robusta con buena cobertura técnica (50 archivos). Principales gaps: falta guía de migración de datos, documentación de tests end-to-end, arquitectura de decisiones (ADRs), y diagramas de infraestructura AWS detallados. Estructura sólida pero mejorable en navegación y consistencia.",
  "overall_score": 7.8,
  "improvements": [
    {
      "priority": "high",
      "category": "content",
      "title": "Documentación de Arquitectura de Decisiones (ADRs)",
      "description": "Faltan registros de decisiones arquitectónicas que expliquen por qué se eligieron tecnologías específicas (Kong vs alternativas, EKS vs ECS, PostgreSQL vs MongoDB, etc). Esto es crítico para onboarding de nuevos desarrolladores y mantenimiento a largo plazo.",
      "files_to_create": [
        "architecture/decision-records/adr-001-api-gateway.mdx",
        "architecture/decision-records/adr-002-kubernetes-eks.mdx",
        "architecture/decision-records/adr-003-database-selection.mdx",
        "architecture/decision-records/index.mdx"
      ],
      "files_to_modify": [
        "architecture.mdx"
      ],
      "files_to_delete": [],
      "proposed_content": "# ADR-001: Selección de Kong como API Gateway\n\n## Estado: Aceptada\n\n## Contexto\nNecesitábamos un API Gateway para gestionar autenticación, rate limiting y enrutamiento entre microservicios.\n\n## Decisión\nKong Gateway open-source con plugins de autenticación JWT.\n\n## Consecuencias\n**Positivas**: Escalable, plugins extensibles, comunidad activa.\n**Negativas**: Curva de aprendizaje, requiere base de datos PostgreSQL.",
      "mermaid_diagram": "",
      "rationale": "Los ADRs documentan el 'por qué' de decisiones técnicas, reduciendo deuda técnica y facilitando refactorizaciones futuras. Es una práctica estándar en arquitecturas complejas que aquí falta completamente."
    },
    {
      "priority": "high",
      "category": "diagrams",
      "title": "Diagrama de Infraestructura AWS Completo",
      "description": "No existe un diagrama visual que muestre la topología completa de AWS: VPC, subnets, security groups, NAT gateways, load balancers, RDS, CloudFront, Route53. Solo hay descripciones textuales fragmentadas.",
      "files_to_create": [
        "infrastructure/aws-topology.mdx"
      ],
      "files_to_modify": [
        "infrastructure/overview.mdx"
      ],
      "files_to_delete": [],
      "proposed_content": "",
      "mermaid_diagram": "graph TB\n    subgraph Internet\n        U[Usuarios]\n        CF[CloudFront CDN]\n    end\n    subgraph Route53\n        DNS[Zona DNS retrogame.cloud]\n    end\n    subgraph VPC[VPC 10.0.0.0/16]\n        subgraph PublicSubnets[Subnets Públicas]\n            ALB[Application Load Balancer]\n            NAT1[NAT Gateway AZ-1]\n            NAT2[NAT Gateway AZ-2]\n        end\n        subgraph PrivateSubnets[Subnets Privadas]\n            EKS[EKS Cluster]\n            subgraph EKSNodes[Nodos EKS]\n                Kong[Kong Gateway]\n                Auth[Auth Service]\n                Game[Game Catalog]\n                Score[Score Service]\n                Rank[Ranking Service]\n                User[User Service]\n            end\n        end\n        subgraph DataSubnets[Subnets de Datos]\n            RDS[(RDS PostgreSQL Multi-AZ)]\n            Redis[(ElastiCache Redis)]\n        end\n    end\n    U -->|HTTPS| CF\n    CF -->|Origin| DNS\n    DNS --> ALB\n    ALB --> Kong\n    Kong --> Auth\n    Kong --> Game\n    Kong --> Score\n    Kong --> Rank\n    Kong --> User\n    Auth -.->|Lectura/Escritura| RDS\n    Game -.->|Lectura| RDS\n    Score -.->|Escritura| RDS\n    Rank -.->|Cache| Redis\n    User -.->|Lectura/Escritura| RDS\n    EKSNodes -->|Salida Internet| NAT1\n    EKSNodes -->|Salida Internet| NAT2",
      "rationale": "Un diagrama visual de infraestructura es esencial para troubleshooting, auditorías de seguridad, y planificación de DR. Actualmente la información está dispersa en múltiples archivos sin visión unificada."
    },
    {
      "priority": "high",
      "category": "content",
      "title": "Guía de Migración y Rollback de Base de Datos",
      "description": "Falta documentación sobre cómo ejecutar migraciones de esquema en RDS PostgreSQL de forma segura, estrategias de versionado de esquema, y procedimientos de rollback en caso de fallos.",
      "files_to_create": [
        "infrastructure/database-migrations.mdx"
      ],
      "files_to_modify": [
        "infrastructure/database.mdx",
        "cicd/gitops-workflow.mdx"
      ],
      "files_to_delete": [],
      "proposed_content": "# Migraciones de Base de Datos\n\n## Herramientas\nUtilizamos Flyway para versionado de esquema con migraciones SQL versionadas.\n\n## Proceso de Migración\n1. Crear script en migrations/V{version}__{descripcion}.sql\n2. Probar en entorno local con Docker\n3. Ejecutar en staging vía Job de Kubernetes\n4. Validar integridad con tests automatizados\n5. Desplegar en producción con ventana de mantenimiento\n\n## Rollback\nMigraciones destructivas requieren script de rollback en migrations/U{version}__{descripcion}.sql. Nunca hacer DROP COLUMN sin ventana de mantenimiento aprobada.",
      "mermaid_diagram": "sequenceDiagram\n    participant Dev as Desarrollador\n    participant Git as GitHub\n    participant CI as GitHub Actions\n    participant K8s as Kubernetes Job\n    participant RDS as RDS PostgreSQL\n    Dev->>Git: Push migration V023__add_achievements.sql\n    Git->>CI: Trigger Pipeline\n    CI->>CI: Validar sintaxis SQL\n    CI->>K8s: Crear Job Flyway\n    K8s->>RDS: Conectar con credenciales secretas\n    RDS->>RDS: Verificar versión actual (V022)\n    K8s->>RDS: Ejecutar V023\n    RDS-->>K8s: Migración exitosa\n    K8s->>RDS: Actualizar schema_version a V023\n    K8s-->>CI: Job completado\n    CI-->>Dev: Notificación de éxito",
      "rationale": "Las migraciones de base de datos son una de las operaciones más riesgosas en producción. Sin documentación clara, los equipos cometen errores que resultan en downtime o pérdida de datos."
    },
    {
      "priority": "high",
      "category": "content",
      "title": "Estrategia de Tests End-to-End",
      "description": "Existe testing-guide.mdx pero no documenta tests E2E que validen flujos completos de usuario (registro -> login -> jugar -> submit score -> ver ranking). Crítico para CI/CD confiable.",
      "files_to_create": [
        "development/e2e-testing.mdx"
      ],
      "files_to_modify": [
        "development/testing-guide.mdx",
        "cicd/github-actions.mdx"
      ],
      "files_to_delete": [],
      "proposed_content": "# Tests End-to-End\n\n## Herramientas\n- Playwright para tests de interfaz\n- newman para tests de API con Postman collections\n\n## Escenarios Críticos\n\n### E2E-001: Flujo Completo de Jugador\n1. Registro de usuario nuevo\n2. Login y obtención de JWT\n3. Listar catálogo de juegos\n4. Cargar juego con js-dos\n5. Guardar puntuación\n6. Verificar aparición en ranking\n\n### E2E-002: Flujo de Autenticación OAuth2\n1. Inicio de sesión con Google\n2. Callback y generación de JWT\n3. Acceso a recursos protegidos\n\n## Ejecución en CI\nLos tests E2E se ejecutan en GitHub Actions contra un cluster efímero de Kubernetes con servicios mock.",
      "mermaid_diagram": "graph LR\n    A[Test Runner Playwright] --> B[Frontend]\n    B --> C[Kong Gateway]\n    C --> D[Auth Service]\n    C --> E[Game Catalog]\n    C --> F[Score Service]\n    C --> G[Ranking Service]\n    D --> H[(PostgreSQL Test DB)]\n    F --> H\n    G --> I[(Redis Test Cache)]\n    A --> J{Validaciones}\n    J -->|Status 200| K[Test Pass]\n    J -->|Status 4xx/5xx| L[Test Fail]\n    J -->|Timeout| L",
      "rationale": "Los tests E2E son la última línea de defensa antes de producción. Sin ellos, los despliegues dependen de tests manuales, aumentando el riesgo de regresiones."
    },
    {
      "priority": "high",
      "category": "diagrams",
      "title": "Diagrama de Flujo de Datos de Puntuaciones",
      "description": "El proceso de submit score -> actualización de ranking -> invalidación de cache no está visualizado. Esto es crítico porque involucra múltiples servicios y Redis.",
      "files_to_create": [],
      "files_to_modify": [
        "services/score-service.mdx",
        "services/ranking-service.mdx"
      ],
      "files_to_delete": [],
      "proposed_content": "",
      "mermaid_diagram": "sequenceDiagram\n    participant U as Usuario\n    participant F as Frontend\n    participant K as Kong Gateway\n    participant S as Score Service\n    participant DB as PostgreSQL\n    participant R as Ranking Service\n    participant Cache as Redis\n    U->>F: Terminar juego con score 9500\n    F->>K: POST /api/scores {gameId, score, JWT}\n    K->>K: Validar JWT\n    K->>S: Reenviar request\n    S->>DB: SELECT best_score WHERE userId AND gameId\n    DB-->>S: best_score = 8000\n    S->>S: Comparar 9500 > 8000\n    S->>DB: UPDATE scores SET score=9500\n    DB-->>S: Actualización exitosa\n    S->>R: POST /internal/rankings/invalidate {gameId}\n    R->>Cache: DEL ranking:game:{gameId}\n    Cache-->>R: Cache invalidada\n    R-->>S: ACK\n    S-->>K: 200 OK {newBestScore: 9500}\n    K-->>F: Respuesta\n    F->>F: Mostrar felicitación nuevo récord\n    Note over R,Cache: Próxima petición GET /rankings/{gameId} regenerará cache desde DB",
      "rationale": "Este flujo es complejo y tiene implicaciones de consistencia eventual. Documentarlo previene bugs donde el ranking no se actualiza correctamente tras un nuevo score."
    },
    {
      "priority": "medium",
      "category": "content",
      "title": "Guía de Troubleshooting de Redis",
      "description": "El sistema usa Redis para rankings pero no hay documentación específica sobre problemas comunes: cache eviction, conexiones máximas, cluster vs standalone, persistence RDB/AOF.",
      "files_to_create": [
        "infrastructure/redis-troubleshooting.mdx"
      ],
      "files_to_modify": [
        "troubleshooting-production.mdx",
        "infrastructure/monitoring.mdx"
      ],
      "files_to_delete": [],
      "proposed_content": "# Troubleshooting de Redis\n\n## Problema: Rankings Desactualizados\n\n**Síntomas**: Los rankings muestran datos antiguos incluso después de nuevos scores.\n\n**Diagnóstico**:"
    }
  ]
}