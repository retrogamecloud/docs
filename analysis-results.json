{
  "analysis_summary": "La documentación está bien estructurada pero presenta gaps críticos: falta arquitectura de datos detallada, patrones de resiliencia, guías de migración/rollback, métricas de observabilidad, y diagramas de componentes internos de servicios. La estructura es sólida pero necesita consolidación en secciones redundantes y profundización en aspectos operacionales.",
  "overall_score": 7.2,
  "improvements": [
    {
      "priority": "high",
      "category": "content",
      "title": "Arquitectura de Datos y Modelos",
      "description": "Falta documentación completa de los modelos de datos, esquemas de base de datos, relaciones entre entidades, estrategia de caché en Redis y políticas de consistencia. Es crítico para desarrolladores que necesitan entender el dominio.",
      "files_to_create": [
        "architecture/data-architecture.mdx",
        "architecture/database-schemas.mdx",
        "architecture/cache-strategy.mdx"
      ],
      "files_to_modify": [
        "architecture.mdx"
      ],
      "files_to_delete": [],
      "proposed_content": "Documento detallando: 1) Diagrama ER de PostgreSQL con todas las tablas (users, games, scores, rankings), 2) Estructura de datos en Redis (sesiones JWT, cache de rankings), 3) Políticas de TTL y invalidación de caché, 4) Estrategias de migración de esquemas con flyway/liquibase",
      "mermaid_diagram": "erDiagram USERS ||--o{ SCORES : submits USERS { string id PK string username UK string email UK string password_hash timestamp created_at } GAMES ||--o{ SCORES : has GAMES { string id PK string slug UK string title string description string jsdos_url timestamp created_at } SCORES ||--o{ RANKINGS : generates SCORES { string id PK string user_id FK string game_id FK int score timestamp achieved_at } RANKINGS { string id PK string game_id FK string user_id FK int rank int score timestamp updated_at }",
      "rationale": "Sin conocer los modelos de datos es imposible contribuir efectivamente al backend. Los desarrolladores necesitan ver las relaciones, índices y constraints para escribir queries eficientes y evitar bugs de integridad referencial."
    },
    {
      "priority": "high",
      "category": "diagrams",
      "title": "Diagrama de Componentes Detallado por Servicio",
      "description": "Cada microservicio necesita un diagrama de componentes mostrando su arquitectura interna: controladores, servicios, repositorios, middlewares, y dependencias externas. Actualmente solo hay diagramas de alto nivel.",
      "files_to_create": [
        "services/auth-service-architecture.mdx",
        "services/score-service-architecture.mdx",
        "services/catalog-service-architecture.mdx"
      ],
      "files_to_modify": [
        "services/auth-service.mdx",
        "services/score-service.mdx",
        "services/game-catalog.mdx"
      ],
      "files_to_delete": [],
      "proposed_content": "Cada servicio debe documentar: Capas (Controllers, Business Logic, Data Access), Dependencias inyectadas, Configuración de validadores (Joi/Yup), Middlewares aplicados (auth, rate-limiting), Clientes externos (DB, Redis, otros servicios).",
      "mermaid_diagram": "graph TB subgraph AuthService A[API Routes] --> B[AuthController] B --> C[AuthService] C --> D[UserRepository] C --> E[JWTService] D --> F[(PostgreSQL)] E --> G[(Redis)] B --> H[ValidationMiddleware] B --> I[ErrorHandler] end subgraph Dependencies J[bcrypt] K[jsonwebtoken] C --> J C --> K end",
      "rationale": "Los desarrolladores necesitan entender la arquitectura interna de cada servicio para debuggear, extender funcionalidad o refactorizar sin romper dependencias. Sin esto, la curva de aprendizaje es muy alta."
    },
    {
      "priority": "high",
      "category": "content",
      "title": "Estrategia de Resiliencia y Manejo de Fallos",
      "description": "No existe documentación sobre patrones de resiliencia: circuit breakers, retries, timeouts, fallbacks, health checks detallados. Crítico para producción robusta.",
      "files_to_create": [
        "architecture/resilience-patterns.mdx",
        "operations/health-monitoring.mdx",
        "operations/failure-scenarios.mdx"
      ],
      "files_to_modify": [
        "architecture.mdx",
        "troubleshooting.mdx"
      ],
      "files_to_delete": [],
      "proposed_content": "Documentar: 1) Circuit breakers entre servicios (configuración, thresholds), 2) Políticas de retry exponencial, 3) Timeouts en llamadas HTTP/DB, 4) Fallbacks (cache stale, respuestas degradadas), 5) Health checks de liveness y readiness para K8s, 6) Estrategias de backpressure y rate limiting",
      "mermaid_diagram": "stateDiagram-v2 [*] --> Closed Closed --> Open : Fallos > threshold Open --> HalfOpen : Timeout transcurrido HalfOpen --> Closed : Request exitoso HalfOpen --> Open : Request falla Open --> [*] : Service degradado Closed --> [*] : Operación normal",
      "rationale": "Sin patrones de resiliencia, un fallo en un servicio puede causar cascada de fallos. La documentación debe guiar implementación de circuit breakers, especialmente en llamadas entre microservicios y a Redis/PostgreSQL."
    },
    {
      "priority": "high",
      "category": "content",
      "title": "Guía de Migración y Rollback",
      "description": "Falta documentación sobre cómo realizar migraciones de base de datos, actualizaciones de esquemas, y procedimientos de rollback en caso de despliegue fallido. Esencial para operaciones seguras.",
      "files_to_create": [
        "operations/migration-guide.mdx",
        "operations/rollback-procedures.mdx",
        "operations/blue-green-deployment.mdx"
      ],
      "files_to_modify": [
        "deployment.mdx",
        "cicd/gitops-workflow.mdx"
      ],
      "files_to_delete": [],
      "proposed_content": "Incluir: 1) Estrategia de migraciones de DB (forward/backward compatible), 2) Scripts de rollback para cada versión, 3) Procedimiento de despliegue blue-green, 4) Checklist pre/post despliegue, 5) Cómo revertir cambios en ArgoCD, 6) Backup y restore de datos críticos, 7) Ventanas de mantenimiento y comunicación",
      "mermaid_diagram": "sequenceDiagram participant DevOps participant ArgoCD participant EKS participant PostgreSQL participant Monitoring DevOps->>ArgoCD: Sync nueva versión ArgoCD->>EKS: Deploy green environment EKS->>PostgreSQL: Aplicar migraciones forward-compatible DevOps->>Monitoring: Verificar métricas alt Despliegue exitoso DevOps->>EKS: Cambiar tráfico a green DevOps->>EKS: Eliminar blue environment else Fallo detectado DevOps->>ArgoCD: Rollback a versión anterior ArgoCD->>EKS: Restaurar blue environment DevOps->>PostgreSQL: Ejecutar rollback SQL end",
      "rationale": "Las migraciones de BD son el punto más riesgoso en despliegues. Sin procedimientos claros de rollback, un fallo puede resultar en downtime prolongado o pérdida de datos. Esto debe estar perfectamente documentado."
    },
    {
      "priority": "high",
      "category": "content",
      "title": "Métricas y Observabilidad Detallada",
      "description": "La sección de monitorización es superficial. Falta especificar qué métricas exactas recoger (RED method, USE method), dashboards de Grafana, alertas de Prometheus, traces distribuidos, y logs estructurados.",
      "files_to_create": [
        "operations/metrics-catalog.mdx",
        "operations/alerting-rules.mdx",
        "operations/distributed-tracing.mdx",
        "operations/log-aggregation.mdx"
      ],
      "files_to_modify": [
        "infrastructure/monitoring.mdx"
      ],
      "files_to_delete": [],
      "proposed_content": "Especificar: 1) Métricas clave por servicio (latencia p50/p95/p99, tasa error, throughput), 2) Configuración de Prometheus ServiceMonitor, 3) Reglas de alertas (thresholds, severidad), 4) Dashboards Grafana JSON, 5) Jaeger/Tempo para tracing, 6) Correlación de logs con trace IDs, 7) SLIs/SLOs/SLAs definidos",
      "mermaid_diagram": "graph LR subgraph Servicios A[Auth Service] --> M1[Prometheus Metrics] B[Score Service] --> M2[Prometheus Metrics] C[Catalog Service] --> M3[Prometheus Metrics] end subgraph Observabilidad M1 --> P[Prometheus] M2 --> P M3 --> P P --> G[Grafana Dashboards] P --> AM[AlertManager] A --> J[Jaeger Tracing] B --> J C --> J A --> L[Loki Logs] B --> L C --> L end subgraph Alertas AM --> S[Slack] AM --> PS[PagerDuty] end",
      "rationale": "Sin observabilidad detallada es imposible detectar degradación de servicio antes de que afecte usuarios. Necesitamos métricas específicas, dashboards útiles y alertas accionables, no solo mencionar que existe Prometheus."
    },
    {
      "priority": "medium",
      "category": "content",
      "title": "Gestión de Secretos y Seguridad",
      "description": "Falta documentación sobre gestión segura de secretos (AWS Secrets Manager, K8s Secrets, Sealed Secrets), rotación de credenciales, políticas de RBAC, y auditoría de seguridad.",
      "files_to_create": [
        "security/secrets-management.mdx",
        "security/rbac-policies.mdx",
        "security/security-audit.mdx",
        "security/compliance.mdx"
      ],
      "files_to_modify": [
        "configuration.mdx"
      ],
      "files_to_delete": [],
      "proposed_content": "Documentar: 1) Uso de AWS Secrets Manager para credenciales DB, 2) External Secrets Operator en K8s, 3) Sealed Secrets para GitOps seguro, 4) Rotación automática de secrets, 5) RBAC de K8s por namespace, 6) Network Policies, 7) Pod Security Standards, 8) Escaneo de vulnerabilidades con Trivy",
      "mermaid_diagram": "graph TB A[AWS Secrets Manager] --> B[External Secrets Operator] B --> C[Kubernetes Secrets] C --> D[Pod: Auth Service] A --> E[RDS Credentials] A --> F[Redis Credentials] A --> G[JWT Secret] H[GitHub Repo] --> I[Sealed Secrets] I --> B J[Developer] -.No acceso directo.-> A J --> K[kubectl con RBAC] K --> L[Namespace dev]",
      "rationale": "La seguridad es crítica en aplicaciones con autenticación. Debe haber guías claras sobre cómo gestionar secretos sin exponerlos en Git, cómo rotarlos, y cómo auditar accesos. Actualmente solo menciona variables de entorno sin contexto seguro."
    },
    {
      "priority": "medium",
      "category": "diagrams",
      "title": "Flujo Completo de Datos de Puntuaciones",
      "description": "Falta un diagrama de secuencia detallado mostrando el flujo completo desde que un usuario envía un score hasta que aparece en el ranking, incluyendo validaciones, actualizaciones de caché, y propagación.",
      "files_to_create": [
        "architecture/score-data-flow.mdx"
      ],
      "files_to_modify": [
        "sequence-diagrams.mdx",
        "services/score-service.mdx"
      ],
      "files_to_delete": [],
      "proposed_content": "Diagrama mostrando: 1) Usuario envía score desde frontend, 2) Kong valida JWT, 3) Score Service valida que sea mejor que el anterior, 4) Guarda en PostgreSQL, 5) Invalida caché de ranking en Redis, 6) Ranking Service recalcula top 10, 7) Notificación opcional al usuario",
      "mermaid_diagram": "sequenceDiagram actor U as Usuario participant F as Frontend participant K as Kong Gateway participant SS as Score Service participant DB as PostgreSQL participant R as Redis participant RS as Ranking Service U->>F: Envía score (gameId, score) F->>K: POST /api/scores + JWT K->>K: Valida JWT K->>SS: Forward request SS->>DB: SELECT current_score WHERE user_id AND game_id alt score > current_score SS->>DB: UPDATE scores SET score=new_score SS->>R: DEL cache:ranking:{gameId} SS->>RS: Trigger ranking update (async) RS->>DB: SELECT TOP 10 scores RS->>R: SET cache:ranking:{gameId} TTL 300s SS-->>F: 200 OK {updated: true} else score <= current_score SS-->>F: 200 OK {updated: false} end F->>U: Mostrar confirmación",
      "rationale": "El flujo de scores es crítico para la lógica de negocio. Los desarrolladores necesitan ver todas las validaciones, transacciones DB, y actualizaciones de caché para entender el comportamiento y optimizar performance."
    },
    {
      "priority": "medium",
      "category": "content",
      "title": "Optimización de Rendimiento y Caching",
      "description": "No hay documentación sobre estrategias de optimización: query optimization, índices de BD, políticas de caching, CDN caching, lazy loading, paginación. Necesario para escalabilidad.",
      "files_to_create": [
        "performance/optimization-guide.mdx",
        "performance/database-indexing.mdx",
        "performance/caching-strategies.mdx"
      ],
      "files_to_modify": [
        "architecture/cache-strategy.mdx"
      ],
      "files_to_delete": [],
      "proposed_content": "Incluir: 1) Índices recomendados en PostgreSQL (user_id, game_id, score para rankings), 2) Query optimization tips (EXPLAIN ANALYZE), 3) Redis caching layers (L1: rankings, L2: game metadata), 4) CloudFront caching para assets estáticos, 5) Lazy loading de imágenes de juegos, 6) Paginación en listados, 7) Connection pooling en servicios",
      "mermaid_diagram": "graph TB U[Usuario] --> CF[CloudFront CDN] CF -->|Cache HIT| A[Assets estáticos] CF -->|Cache MISS| S3[S3 Bucket] U --> ALB[Application LB] ALB --> K[Kong Gateway] K --> SS[Score Service] SS -->|Check L1| R1[Redis: Rankings Cache] R1 -->|HIT| SS R1 -->|MISS| SS SS -->|Query| DB[(PostgreSQL)] DB -->|Índices optimizados| SS SS -->|Store| R1 K --> CS[Catalog Service] CS -->|Check L2| R2[Redis: Games Cache] R2 -->|HIT| CS R2 -->|MISS| CS CS --> DB",
      "rationale": "La performance es clave para buena UX. Sin guías de optimización, los desarrolladores pueden escribir queries lentos, no cachear apropiadamente, o saturar la BD. Documentar best practices previene problemas de escalabilidad."
    },
    {
      "priority": "medium",
      "category": "content",
      "title": "Pruebas y Calidad de Código",
      "description": "Falta documentación sobre estrategia de testing: unit tests, integration tests, e2e tests, test coverage mínimo, mocking, test fixtures, y CI pipelines para testing.",
      "files_to_create": [
        "development/testing-strategy.mdx",
        "development/unit-tests.mdx",
        "development/integration-tests.mdx",
        "development/e2e-tests.mdx"
      ],
      "files_to_modify": [
        "development.mdx",
        "cicd/github-actions.mdx"
      ],
      "files_to_delete": [],
      "proposed_content": "Especificar: 1) Frameworks (Jest, Supertest, Cypress), 2) Coverage mínimo 80%, 3) Estructura de tests por servicio, 4) Mocking de DB y Redis con testcontainers, 5) Test fixtures y factory patterns, 6) CI pipeline que falla si coverage < threshold, 7) E2E tests en staging pre-producción",
      "mermaid_diagram": "graph TB subgraph Developer Machine D[Desarrollador] --> U[Unit Tests: Jest] U --> I[Integration Tests: Supertest] I --> L[Lint: ESLint] end subgraph CI Pipeline GitHub Actions G[Git Push] --> B[Build Docker Image] B --> UT[Run Unit Tests] UT --> IT[Run Integration Tests] IT --> SC[SonarQube Scan] SC --> COV{Coverage > 80%} COV -->|Yes| PUSH[Push to Registry] COV -->|No| FAIL[Build Failed] end subgraph CD Pipeline ArgoCD PUSH --> A[ArgoCD Detect] A --> DS[Deploy to Staging] DS --> E2E[E2E Tests: Cypress] E2E --> PROD{Tests Pass} PROD -->|Yes| DP[Deploy to Prod] PROD -->|No| RB[Rollback] end",
      "rationale": "Sin tests automatizados, cada cambio es riesgoso. Debe haber guías claras sobre qué testear, cómo estructurar tests, y qué herramientas usar. La cobertura debe medirse y enforcearse en CI."
    },
    {
      "priority": "medium",
      "category": "structure",
      "title": "Consolidar Documentación API Redundante",
      "description": "Existe duplicación entre api-reference/* y services/*. Por ejemplo, auth-service.mdx y api-reference/auth-service.mdx. Consolidar en una estructura única referenciando OpenAPI/Swagger.",
      "files_to_create": [
        "api-reference/openapi-spec.mdx"
      ],
      "files_to_modify": [
        "services/auth-service.mdx",
        "services/score-service.mdx",
        "services/game-catalog.mdx"
      ],
      "files_to_delete": [
        "api-reference/auth-service.mdx",
        "api-reference/score-service.mdx",
        "api-reference/game-catalog-service.mdx"
      ],
      "proposed_content": "Mantener documentación de servicios en services/* con visión arquitectónica. En api-reference/* solo specs OpenAPI completas generadas automáticamente. Integrar Swagger UI embebido en la documentación para exploración interactiva.",
      "mermaid_diagram": "",
      "rationale": "La duplicación genera inconsistencias y dificulta mantenimiento. Mejor tener una única fuente de verdad: servicios documentan arquitectura, API reference apunta a specs OpenAPI autogeneradas desde el código."
    },
    {
      "priority": "medium",
      "category": "content",
      "title": "Costes y Estimaciones de AWS",
      "description": "Falta documentación sobre costes estimados de infraestructura AWS, breakdown por servicio (EKS, RDS, CloudFront, S3), y estrategias de optimización de costes.",
      "files_to_create": [
        "operations/cost-estimation.mdx",
        "operations/cost-optimization.mdx"
      ],
      "files_to_modify": [
        "quickstart.mdx",
        "deployment.mdx"
      ],
      "files_to_delete": [],
      "proposed_content": "Incluir: 1) Estimación mensual de costes por entorno (dev/staging/prod), 2) Breakdown: EKS nodes (~$150/mes), RDS PostgreSQL (~$50/mes), CloudFront (~$10/mes), S3 (~$5/mes), 3) Estrategias: Spot instances para workers, rightsizing de instancias, S3 lifecycle policies, CloudFront cache optimization, 4) Herramientas: AWS Cost Explorer, tags de recursos",
      "mermaid_diagram": "pie title Costes Mensuales AWS Estimados (Producción) \"EKS Cluster (3 nodes t3.medium)\" : 150 \"RDS PostgreSQL (db.t3.small)\" : 50 \"ElastiCache Redis (cache.t3.micro)\" : 25 \"Application Load Balancer\" : 25 \"CloudFront CDN\" : 15 \"S3 Storage\" : 10 \"Route53\" : 5 \"Secrets Manager\" : 5 \"CloudWatch\" : 15",
      "rationale": "Los usuarios necesitan saber cuánto costará ejecutar la plataforma antes de desplegarla. Sin estimaciones, pueden tener sorpresas en la factura. También necesitan estrategias para optimizar costes sin sacrificar performance."
    },
    {
      "priority": "low",
      "category": "content",
      "title": "Guía de Contribución y Estándares de Código",
      "description": "Falta un CONTRIBUTING.md detallado con guías de estilo, convenciones de código, proceso de PR, branching strategy, y cómo contribuir a la documentación.",
      "files_to_create": [
        "CONTRIBUTING.md",
        "development/code-standards.mdx",
        "development/git-workflow.mdx"
      ],
      "files_to_modify": [
        "README.md"
      ],
      "files_to_delete": [],
      "proposed_content": "Incluir: 1) Code style (Airbnb ESLint config), 2) Commit message conventions (Conventional Commits), 3) Branching strategy (GitFlow: main, develop, feature/*, hotfix/*), 4) PR template y checklist, 5) Code review guidelines, 6) Cómo reportar bugs, 7) Cómo proponer nuevas features",
      "mermaid_diagram": "gitGraph commit id: \"Initial commit\" branch develop checkout develop commit id: \"Setup base\" branch feature/auth-jwt checkout feature/auth-jwt commit id: \"Implement JWT\" commit id: \"Add tests\" checkout develop merge feature/auth-jwt commit id: \"Merge auth\" branch release/1.0 checkout release/1.0 commit id: \"Bump version\" checkout main merge release/1.0 tag: \"v1.0.0\" checkout develop merge release/1.0 branch hotfix/security checkout hotfix/security commit id: \"Fix vulnerability\" checkout main merge hotfix/security tag: \"v1.0.1\" checkout develop merge hotfix/security",
      "rationale": "Para que el proyecto sea sostenible y escalable con múltiples contribuidores, necesita guías claras de contribución. Sin esto, el código se vuelve inconsistente, los PRs son difíciles de revisar, y la calidad degrada."
    },
    {
      "priority": "low",
      "category": "content",
      "title": "Casos de Uso y User Stories",
      "description": "La documentación es muy técnica pero falta contexto de negocio: casos de uso reales, user journeys, personas, y decisiones de producto. Útil para entender el por qué detrás de decisiones técnicas.",
      "files_to_create": [
        "product/use-cases.mdx",
        "product/user-journeys.mdx",
        "product/roadmap.mdx"
      ],
      "files_to_modify": [
        "index.mdx"
      ],
      "files_to_delete": [],
      "proposed_content": "Documentar: 1) Personas (Jugador Casual, Speedrunner, Coleccionista), 2) User journeys (Registro → Buscar juego → Jugar → Guardar score → Ver ranking), 3) Casos de uso (compartir scores en redes, desafíos entre amigos), 4) Roadmap de features (multiplayer, chat, torneos), 5) Decisiones de producto (por qué solo mejor score, no historial completo)",
      "mermaid_diagram": "journey title User Journey: Primera Partida section Descubrimiento Usuario llega a landing: 5: Usuario Ver catálogo de juegos: 4: Usuario section Registro Hacer clic en Registrarse: 3: Usuario Rellenar formulario: 2: Usuario Verificar email: 3: Usuario section Juego Seleccionar juego nostálgico: 5: Usuario Cargar emulador js-dos: 4: Sistema Jugar y disfrutar: 5: Usuario section Competición Ver puntuación final: 4: Usuario Guardar score en ranking: 5: Usuario Ver posición en top 10: 5: Usuario Compartir logro: 4: Usuario",
      "rationale": "Documentar el contexto de producto ayuda a que los contribuidores entiendan el propósito del sistema, no solo cómo funciona técnicamente. Esto guía mejores decisiones de arquitectura alineadas con necesidades de usuarios."
    },
    {
      "priority": "low",
      "category": "quality",
      "title": "Actualizar Referencias a Mintlify",
      "description": "El archivo development.mdx contiene contenido genérico de Mintlify (Preview changes locally to update your docs) que no aplica a este proyecto. Debe actualizarse con instrucciones específicas de Retro Game Hub.",
      "files_to_create": [],
      "files_to_modify": [
        "development.mdx"
      ],
      "files_to_delete": [],
      "proposed_content": "Reemplazar con: Guía de desarrollo local para Retro Game Hub con pasos específicos: clonar repos, configurar variables de entorno, levantar servicios con docker-compose, ejecutar migraciones, popular datos de prueba, ejecutar tests.",
      "mermaid_diagram": "",
      "rationale": "El contenido genérico confunde a los desarrolladores. La documentación debe ser 100% específica del proyecto, sin templates ni placeholders."
    },
    {
      "priority": "low",
      "category": "content",
      "title": "Disaster Recovery y Backup",
      "description": "Falta documentación sobre estrategias de disaster recovery: backups automáticos de RDS, snapshots de volúmenes, restore procedures, RPO/RTO targets, y plan de continuidad de negocio.",
      "files_to_create": [
        "operations/disaster-recovery.mdx",
        "operations/backup-strategy.mdx"
      ],
      "files_to_modify": [
        "deployment.mdx"
      ],
      "files_to_delete": [],
      "proposed_content": "Documentar: 1) RDS automated backups (retention 7 días), 2) Manual snapshots pre-cambios críticos, 3) Cross-region replication para HA, 4) Procedimiento de restore desde backup, 5) Simulacros de DR trimestrales, 6) RPO 1 hora, RTO 4 horas, 7) Backup de configuraciones K8s en Git (GitOps), 8) Backup de secretos encriptados",
      "mermaid_diagram": "graph TB subgraph Producción P[RDS Primary eu-west-1] --> B1[Automated Backup Diario] P --> S1[Manual Snapshot Pre-deploy] P --> R[Read Replica eu-west-1] end subgraph Disaster Recovery B1 --> S3[S3 Backup Bucket] S1 --> S3 P -.Cross-region replication.-> DR[RDS Standby us-east-1] DR --> B2[Automated Backup Diario] end subgraph Restore Procedure S3 --> RT{Restore Type} RT -->|Full| RFULL[Create new RDS from snapshot] RT -->|Point-in-time| RPIT[PITR desde backup] RFULL --> V[Validar datos] RPIT --> V V --> SW[Switch DNS] end",
      "rationale": "Sin plan de DR, un desastre (fallo de región AWS, corrupción de datos, ataque) puede significar pérdida permanente de datos. Debe haber procedimientos claros, testados regularmente, para recuperarse de cualquier escenario."
    }
  ],
  "new_sections": [
    {
      "name": "Arquitectura de Datos",
      "description": "Sección dedicada a modelos de datos, esquemas de base de datos, relaciones entre entidades, y estrategias de persistencia y caché",
      "files": [
        {
          "filename": "architecture/data-architecture.mdx",
          "title": "Arquitectura de Datos",
          "content_outline": "Introducción a la arquitectura de datos, diagrama ER completo, decisiones de diseño (por qué PostgreSQL, por qué Redis), patrones de acceso a datos, consistencia eventual vs fuerte"
        },
        {
          "filename": "architecture/database-schemas.mdx",
          "title": "Esquemas de Base de Datos",
          "content_outline": "Esquemas SQL completos de todas las tablas (users, games, scores, rankings), índices creados, constraints, triggers si existen, vistas materializadas"
        },
        {
          "filename": "architecture/cache-strategy.mdx",
          "title": "Estrategia de Caché",
          "content_outline": "Qué se cachea en Redis (rankings, sesiones JWT, metadatos de juegos), TTL por tipo de dato, políticas de invalidación (write-through, cache-aside), dimensionamiento de Redis"
        }
      ]
    },
    {
      "name": "Operaciones y SRE",
      "description": "Sección para Site Reliability Engineering: observabilidad, incident response, disaster recovery, runbooks, y operational excellence",
      "files": [
        {
          "filename": "operations/metrics-catalog.mdx",
          "title": "Catálogo de Métricas",
          "content_outline": "Lista completa de métricas expuestas por cada servicio (latencia, error rate, throughput), formato Prometheus, queries útiles de PromQL, dashboards recomendados"
        },
        {
          "filename": "operations/alerting-rules.mdx",
          "title": "Reglas de Alertas",
          "content_outline": "Definición de alertas críticas (API error rate > 5%, latencia p95 > 500ms), alertas de warning, configuración de AlertManager, integraciones con Slack/PagerDuty"
        },
        {
          "filename": "operations/incident-response.mdx",
          "title": "Respuesta a Incidentes",
          "content_outline": "Procedimientos de incident response (SEV1/SEV2/SEV3), roles (Incident Commander, Communications Lead), runbooks para incidentes comunes, postmortems sin culpa"
        },
        {
          "filename": "operations/disaster-recovery.mdx",
          "title": "Recuperación ante Desastres",
          "content_outline": "Plan de DR completo, backup/restore procedures, RPO/RTO targets, simulacros de DR, failover a región secundaria, rollback procedures"
        }
      ]
    },
    {
      "name": "Seguridad",
      "description": "Sección dedicada a seguridad, compliance, gestión de secretos, y mejores prácticas de seguridad en cloud-native",
      "files": [
        {
          "filename": "security/secrets-management.mdx",
          "title": "Gestión de Secretos",
          "content_outline": "Uso de AWS Secrets Manager, External Secrets Operator, Sealed Secrets, rotación automática, auditoría de accesos, separación de secretos por entorno"
        },
        {
          "filename": "security/rbac-policies.mdx",
          "title": "Políticas RBAC",
          "content_outline": "Roles y"
        }
      ]
    }
  ]
}