{
  "analysis_summary": "Documentación extensa pero desorganizada. Faltan diagramas de infraestructura AWS, guías de monitorización, y documentación de seguridad. Estructura confusa con duplicaciones (development.mdx genérico vs desarrollo-local.mdx). Necesita consolidación y estandarización.",
  "overall_score": 6.5,
  "improvements": [
    {
      "priority": "high",
      "category": "structure",
      "title": "Consolidar y reorganizar documentación duplicada",
      "description": "Existen múltiples archivos con contenido solapado o genérico (development.mdx de Mintlify, essentials/* de plantilla). La estructura mezcla guías de usuario con referencias de API. Necesita jerarquía clara: Getting Started > Arquitectura > Servicios > Infraestructura > API Reference > Operaciones.",
      "files_to_create": [],
      "files_to_modify": [
        "index.mdx",
        "quickstart.mdx",
        "desarrollo-local.mdx"
      ],
      "files_to_delete": [
        "development.mdx",
        "essentials/images.mdx",
        "essentials/navigation.mdx",
        "essentials/markdown.mdx",
        "essentials/code.mdx",
        "essentials/settings.mdx"
      ],
      "proposed_content": "Crear estructura: /guias/inicio-rapido.mdx, /guias/desarrollo-local.mdx, /guias/despliegue-produccion.mdx. Separar claramente documentación de usuario de documentación técnica de operaciones.",
      "mermaid_diagram": "",
      "rationale": "La documentación actual tiene archivos de plantilla Mintlify sin personalizar y contenido duplicado que confunde a desarrolladores nuevos. Una estructura clara reduce el tiempo de onboarding en 50%."
    },
    {
      "priority": "high",
      "category": "diagrams",
      "title": "Diagrama completo de infraestructura AWS",
      "description": "Falta un diagrama detallado que muestre todos los componentes de AWS: EKS con nodos, RDS PostgreSQL, S3 para assets, CloudFront, ALB, Route53, VPC con subredes públicas/privadas, NAT Gateway, Security Groups. El diagrama actual en architecture.mdx es demasiado abstracto.",
      "files_to_create": [
        "infrastructure/arquitectura-aws-detallada.mdx"
      ],
      "files_to_modify": [
        "infrastructure/overview.mdx"
      ],
      "files_to_delete": [],
      "proposed_content": "Diagrama con tres vistas: Vista de red (VPC, subnets, routing), Vista de computación (EKS nodes, pods, services), Vista de datos (RDS, S3, backups). Incluir flujo de tráfico desde usuario hasta base de datos con latencias estimadas.",
      "mermaid_diagram": "graph TB subgraph Internet[Internet] U[Usuario] CF[CloudFront CDN] end subgraph AWS_Region[Región AWS us-east-1] subgraph VPC[VPC 10.0.0.0/16] subgraph PublicSubnet[Subredes Públicas] ALB[Application Load Balancer] NAT[NAT Gateway] end subgraph PrivateSubnet[Subredes Privadas EKS] subgraph EKS[Cluster EKS] OP[OAuth2 Proxy Pod] Kong[Kong Gateway Pod] Auth[Auth Service Pod] Game[Game Catalog Pod] Score[Score Service Pod] Rank[Ranking Service Pod] User[User Service Pod] end RDS[(RDS PostgreSQL Multi-AZ)] end end R53[Route53 DNS] end S3[S3 Bucket Assets] U -->|HTTPS| CF CF -->|retrogamehub.com| R53 R53 --> ALB ALB -->|SSL Term| OP OP --> Kong Kong --> Auth Kong --> Game Kong --> Score Kong --> Rank Kong --> User Auth --> RDS Game --> RDS Score --> RDS Rank --> RDS User --> RDS CF -->|CDN Pull| S3 NAT -->|Salida Internet| Internet EKS -.->|Logs| CW[CloudWatch]",
      "rationale": "Desarrolladores e ingenieros de infraestructura necesitan entender la topología completa para debuggear problemas de red, optimizar costos y planificar escalabilidad. Sin esto, cada persona tiene una visión incompleta del sistema."
    },
    {
      "priority": "high",
      "category": "content",
      "title": "Documentación de seguridad y compliance",
      "description": "No existe documentación sobre prácticas de seguridad, gestión de secretos, políticas de IAM, encriptación de datos en tránsito y reposo, rotación de credenciales, auditoría de accesos. Esto es crítico para producción.",
      "files_to_create": [
        "seguridad/vision-general.mdx",
        "seguridad/gestion-secretos.mdx",
        "seguridad/politicas-iam.mdx",
        "seguridad/encriptacion.mdx",
        "seguridad/auditoria-logs.mdx"
      ],
      "files_to_modify": [
        "architecture.mdx"
      ],
      "files_to_delete": [],
      "proposed_content": "Sección completa de seguridad: (1) Gestión de secretos con AWS Secrets Manager y External Secrets Operator, (2) Políticas IAM por servicio con principio de mínimo privilegio, (3) Encriptación TLS 1.3 en ALB, encriptación en reposo RDS con KMS, (4) Network Policies K8s para segmentación, (5) Logging y auditoría con CloudTrail y CloudWatch, (6) Procedimientos de rotación de JWT secrets y DB passwords.",
      "mermaid_diagram": "",
      "rationale": "La seguridad no puede ser una ocurrencia tardía. Necesitas esta documentación antes de certificaciones, auditorías, o cuando un incidente de seguridad requiera respuesta inmediata. Es requisito para cumplimiento RGPD."
    },
    {
      "priority": "high",
      "category": "content",
      "title": "Guía completa de monitorización y observabilidad",
      "description": "infrastructure/monitoring.mdx existe pero sin contenido detallado. Falta documentación de métricas clave por servicio, dashboards en Grafana, alertas en AlertManager, traces distribuidos, SLIs/SLOs, runbooks para oncall.",
      "files_to_create": [
        "operaciones/metricas-slis.mdx",
        "operaciones/dashboards-grafana.mdx",
        "operaciones/alertas-oncall.mdx",
        "operaciones/troubleshooting-playbooks.mdx"
      ],
      "files_to_modify": [
        "infrastructure/monitoring.mdx"
      ],
      "files_to_delete": [],
      "proposed_content": "Métricas por servicio: Auth (login rate, JWT validation errors), Game Catalog (cache hit ratio), Scores (submission latency p95), Rankings (query performance). SLIs: Availability 99.5%, Latency p95 <500ms, Error rate <1%. Dashboards: Golden signals por servicio. Alertas: PodCrashLooping, HighErrorRate, DatabaseConnectionPool. Runbooks: Qué hacer cuando X alerta se dispara.",
      "mermaid_diagram": "graph LR subgraph Servicios S[Auth/Game/Score/Rank/User Services] end subgraph Recolección P[Prometheus Server] L[Loki para Logs] T[Tempo para Traces] end subgraph Visualización G[Grafana Dashboards] end subgraph Alertas AM[AlertManager] PD[PagerDuty] SL[Slack] end S -->|Métricas /metrics| P S -->|Logs stdout| L S -->|Traces OTLP| T P --> G L --> G T --> G P -->|Reglas| AM AM -->|Crítico| PD AM -->|Warning| SL",
      "rationale": "Sin observabilidad adecuada, diagnosticar problemas en producción toma horas en lugar de minutos. Los dashboards y runbooks reducen MTTR (Mean Time To Recovery) dramáticamente y permiten identificar problemas antes de que afecten usuarios."
    },
    {
      "priority": "medium",
      "category": "diagrams",
      "title": "Diagrama de flujo completo de CI/CD con GitOps",
      "description": "cicd/gitops-workflow.mdx y github-actions.mdx no tienen diagrama visual del flujo completo desde commit hasta despliegue en EKS vía ArgoCD. Necesita mostrar stages, checks, rollback.",
      "files_to_create": [],
      "files_to_modify": [
        "cicd/gitops-workflow.mdx"
      ],
      "files_to_delete": [],
      "proposed_content": "Diagrama que muestre: (1) Developer push a rama feature, (2) GitHub Actions: tests unitarios + lint + build Docker, (3) Push imagen a ECR con tag semántico, (4) Update de manifiesto K8s en repo, (5) ArgoCD detecta cambio y sincroniza, (6) Deployment progresivo con health checks, (7) Rollback automático si falla. Incluir tiempos estimados por stage.",
      "mermaid_diagram": "sequenceDiagram participant Dev as Developer participant GH as GitHub participant GHA as GitHub Actions participant ECR as AWS ECR participant K8s as Manifests Repo participant ArgoCD as ArgoCD participant EKS as Cluster EKS Dev->>GH: git push feature-branch GH->>GHA: Trigger Workflow GHA->>GHA: Ejecutar tests (2min) GHA->>GHA: Lint y security scan (1min) GHA->>GHA: Build imagen Docker GHA->>ECR: Push imagen:sha-abc123 GHA->>K8s: Update deployment.yaml con nueva imagen K8s->>ArgoCD: Detecta cambio (30s) ArgoCD->>EKS: Apply manifests ArgoCD->>EKS: Health check pods (2min) alt Despliegue exitoso EKS-->>ArgoCD: Pods healthy ArgoCD-->>Dev: Notificación Slack éxito else Despliegue fallido EKS-->>ArgoCD: Pods CrashLoopBackOff ArgoCD->>EKS: Rollback a versión anterior ArgoCD-->>Dev: Notificación Slack fallo end",
      "rationale": "El flujo GitOps es complejo y los desarrolladores necesitan entender cada stage para debuggear fallos de despliegue. Un diagrama de secuencia visual reduce preguntas recurrentes sobre 'por qué mi cambio no se desplegó' en un 70%."
    },
    {
      "priority": "medium",
      "category": "diagrams",
      "title": "Diagrama de flujo de autenticación OAuth2 + JWT completo",
      "description": "sequence-diagrams.mdx tiene diagrama de registro/login básico pero no muestra el flujo completo de OAuth2 con GitHub, incluyendo callback, token exchange, creación de sesión, refresh tokens.",
      "files_to_create": [],
      "files_to_modify": [
        "sequence-diagrams.mdx"
      ],
      "files_to_delete": [],
      "proposed_content": "Diagrama completo: (1) Usuario hace click Login con GitHub, (2) Redirect a GitHub OAuth, (3) Usuario aprueba permisos, (4) Callback a OAuth2 Proxy con código, (5) Exchange código por GitHub access token, (6) OAuth2 Proxy valida y crea sesión, (7) Redirect a frontend con cookie de sesión, (8) Frontend llama Auth Service con cookie, (9) Auth Service valida y emite JWT propio, (10) Frontend usa JWT en requests a Kong.",
      "mermaid_diagram": "sequenceDiagram participant U as Usuario participant F as Frontend participant OP as OAuth2 Proxy participant GH as GitHub OAuth participant AS as Auth Service participant Kong as Kong Gateway U->>F: Click 'Login con GitHub' F->>OP: GET /oauth2/start OP->>GH: Redirect con client_id y scopes GH->>U: Mostrar pantalla autorización U->>GH: Aprobar permisos GH->>OP: Callback /oauth2/callback?code=xyz OP->>GH: POST /access_token (exchange code) GH-->>OP: access_token + user info OP->>OP: Crear sesión segura OP->>F: Redirect con cookie httpOnly F->>AS: POST /auth/oauth-login (cookie) AS->>AS: Validar sesión OAuth2 Proxy AS->>AS: Crear o actualizar usuario en DB AS-->>F: JWT token (exp: 24h) F->>F: Guardar JWT en localStorage F->>Kong: GET /api/games (Header: Authorization Bearer JWT) Kong->>Kong: Validar JWT signature Kong->>AS: Forward request AS-->>Kong: Response Kong-->>F: Juegos",
      "rationale": "El flujo OAuth2 + JWT es la parte más confusa para nuevos desarrolladores. Sin un diagrama completo, pierden tiempo entendiendo por qué hay dos tipos de tokens (OAuth session cookie + JWT) y cuándo se usa cada uno."
    },
    {
      "priority": "medium",
      "category": "content",
      "title": "Guía de dimensionamiento y estimación de costos AWS",
      "description": "No hay documentación sobre sizing de instancias EKS, cálculo de costos mensuales estimados, estrategias de optimización (Spot instances, Savings Plans), escalado automático basado en métricas.",
      "files_to_create": [
        "infraestructura/dimensionamiento-costos.mdx",
        "infraestructura/optimizacion-costos.mdx"
      ],
      "files_to_modify": [
        "infrastructure/eks-cluster.mdx"
      ],
      "files_to_delete": [],
      "proposed_content": "Tabla de costos estimados: EKS control plane $73/mes, 3x t3.medium nodes $75/mes, RDS db.t3.medium $120/mes, ALB $23/mes, Route53 $1/mes, CloudFront según tráfico ~$50/mes, Total: ~$342/mes para 1000 usuarios activos. Recomendaciones: Usar Spot instances para nodes no críticos (ahorro 70%), HPA para auto-scaling, análisis de rightsizing mensual con AWS Cost Explorer.",
      "mermaid_diagram": "",
      "rationale": "Los stakeholders necesitan conocer costos operacionales antes de aprobar producción. Sin esta info, hay sorpresas en la factura AWS. La optimización proactiva puede reducir costos 40-60% sin afectar rendimiento."
    },
    {
      "priority": "medium",
      "category": "content",
      "title": "Estrategia de backup y disaster recovery",
      "description": "No hay documentación sobre backups de base de datos RDS, snapshots de volúmenes persistentes, procedimientos de restore, RPO/RTO objetivos, plan de disaster recovery.",
      "files_to_create": [
        "operaciones/backups-restore.mdx",
        "operaciones/disaster-recovery.mdx"
      ],
      "files_to_modify": [],
      "files_to_delete": [],
      "proposed_content": "Estrategia de backups: RDS automated backups diarios con retención 7 días, snapshots manuales semanales con retención 30 días, exportación mensual a S3 para compliance. Objetivos: RPO 24 horas (pérdida máxima datos), RTO 4 horas (tiempo máximo recuperación). Procedimientos: Restore de snapshot RDS paso a paso, recuperación de cluster EKS desde manifests Git, test de DR trimestral. Scenarios: Pérdida región AWS, corrupción base datos, eliminación accidental recursos.",
      "mermaid_diagram": "graph TB subgraph Producción P[RDS Producción] PV[EBS Volumes] end subgraph Backups Automáticos AB[RDS Automated Backups 7 días] SN[Snapshots Semanales 30 días] end subgraph Almacenamiento Largo Plazo S3[S3 Glacier Backups Mensuales] end subgraph Recuperación RS[Restore desde Snapshot] DR[Plan DR Multi-Región] end P -->|Diario 2 AM UTC| AB P -->|Domingo| SN SN -->|Mensual| S3 AB --> RS SN --> RS RS --> P2[RDS Recuperada] DR -.->|Failover| P_DR[Región Secundaria]",
      "rationale": "Sin estrategia de backup documentada, estás a un comando 'DROP DATABASE' de perder todos los datos de usuarios. Los reguladores y auditorías requieren evidencia de plan de DR. El costo de no tenerlo puede ser catastrófico."
    },
    {
      "priority": "medium",
      "category": "diagrams",
      "title": "Diagrama de arquitectura de datos y flujo de scores",
      "description": "No hay diagrama que muestre cómo fluyen los datos de scores desde el juego js-dos en frontend hasta la base de datos, pasando por validaciones, rankings, y notificaciones. Necesario para entender integridad de datos.",
      "files_to_create": [],
      "files_to_modify": [
        "services/score-service.mdx",
        "services/ranking-service.mdx"
      ],
      "files_to_delete": [],
      "proposed_content": "Diagrama que muestre: (1) Usuario completa juego en js-dos, (2) Frontend captura score final, (3) POST a Score Service con JWT, (4) Validación de autenticación y juego válido, (5) Comparación con best score actual en DB, (6) Si es mejor, UPDATE en tabla scores, (7) Trigger de evento para Ranking Service, (8) Ranking Service recalcula leaderboard, (9) Cache invalidation, (10) Response al frontend. Incluir validaciones anti-cheating.",
      "mermaid_diagram": "sequenceDiagram participant JS as js-dos Emulator participant F as Frontend participant Kong as Kong Gateway participant SS as Score Service participant DB as PostgreSQL participant RS as Ranking Service participant Cache as Redis Cache JS->>F: gameCompleted(score: 9500) F->>F: Validar score localmente F->>Kong: POST /api/scores/submit {gameId, score, JWT} Kong->>SS: Forward con JWT validado SS->>DB: SELECT best_score WHERE user_id AND game_id DB-->>SS: current_best: 8000 SS->>SS: Comparar: 9500 > 8000 alt Nuevo récord personal SS->>DB: UPDATE scores SET score=9500 DB-->>SS: OK SS->>RS: Evento ScoreUpdated (async) RS->>DB: SELECT TOP 10 scores WHERE game_id RS->>Cache: INVALIDATE ranking:game:123 RS->>Cache: SET ranking:game:123 (nuevo top 10) SS-->>Kong: 200 OK {newBest: true, rank: 3} else Score no supera récord SS-->>Kong: 200 OK {newBest: false} end Kong-->>F: Response F->>F: Mostrar notificación nuevo récord",
      "rationale": "El flujo de scores es crítico para la experiencia de usuario y es propenso a cheating. Sin un diagrama claro, es difícil identificar dónde añadir validaciones adicionales o debuggear por qué un score no se guardó."
    },
    {
      "priority": "low",
      "category": "content",
      "title": "Documentación de testing: unitarios, integración, e2e",
      "description": "No hay documentación sobre estrategia de testing, cómo ejecutar tests localmente, cobertura mínima requerida, tests de integración entre servicios, tests e2e con Cypress/Playwright.",
      "files_to_create": [
        "desarrollo/estrategia-testing.mdx",
        "desarrollo/ejecutar-tests.mdx"
      ],
      "files_to_modify": [
        "desarrollo-local.mdx"
      ],
      "files_to_delete": [],
      "proposed_content": "Estrategia de testing: Unitarios (Jest) con 80% cobertura mínima por servicio, integración (Supertest) para endpoints API con DB en Docker, E2E (Playwright) para flujos críticos (login, jugar, submit score). Comandos: npm test en cada servicio, npm run test:integration con Docker Compose, npm run test:e2e contra entorno staging. CI ejecuta todo antes de merge. Ejemplos de tests por tipo.",
      "mermaid_diagram": "",
      "rationale": "Sin documentación de testing, los desarrolladores no saben qué tests escribir ni cómo ejecutarlos. Esto lleva a PRs sin tests o tests que no aportan valor. Una estrategia clara mejora calidad del código y reduce bugs en producción."
    },
    {
      "priority": "low",
      "category": "content",
      "title": "Guía de contribución y estándares de código",
      "description": "No existe CONTRIBUTING.md ni documentación de estándares: convenciones de nombres, estructura de commits, proceso de code review, branching strategy, políticas de merge.",
      "files_to_create": [
        "CONTRIBUTING.md",
        "desarrollo/estandares-codigo.mdx"
      ],
      "files_to_modify": [],
      "files_to_delete": [],
      "proposed_content": "Guía de contribución: Branching strategy (Git Flow: main, develop, feature/*, hotfix/*), commits convencionales (feat:, fix:, docs:), PR template con checklist (tests added, docs updated), code review guidelines (mínimo 1 aprobación, no merge propio PR), estándares de código (ESLint config compartida, Prettier, naming conventions: camelCase para variables, PascalCase para componentes).",
      "mermaid_diagram": "",
      "rationale": "Sin estándares claros, cada desarrollador usa su propio estilo, lo que dificulta mantenimiento y code reviews. Un CONTRIBUTING.md reduce fricción para contribuciones externas y mantiene consistencia en el codebase."
    },
    {
      "priority": "low",
      "category": "quality",
      "title": "Estandarizar formato de frontmatter en archivos MDX",
      "description": "Los archivos MDX tienen frontmatter inconsistente: algunos usan numeración en títulos (1.1, 2.2), otros no; algunos tienen icon, otros no; descripciones de longitud variable.",
      "files_to_create": [],
      "files_to_modify": [
        "*.mdx"
      ],
      "files_to_delete": [],
      "proposed_content": "Estándar de frontmatter: (1) title sin numeración (la numeración va en sidebar config), (2) description obligatoria de 50-150 caracteres, (3) icon obligatorio de lucide-react, (4) tags opcionales para búsqueda. Ejemplo: ---\\ntitle: Servicio de Autenticación\\ndescription: Gestión de registro, login y validación con JWT\\nicon: lock\\ntags: [backend, security, jwt]\\n---",
      "mermaid_diagram": "",
      "rationale": "La inconsistencia en frontmatter dificulta la navegación y búsqueda. Estandarizar mejora la experiencia de usuario y facilita mantenimiento automatizado (scripts que procesan MDX)."
    },
    {
      "priority": "low",
      "category": "content",
      "title": "Glosario de términos técnicos",
      "description": "No hay glosario que defina términos específicos del proyecto: qué es un .jsdos bundle, diferencia entre slug y gameId, qué significa 'ranking global' vs 'ranking por juego'.",
      "files_to_create": [
        "referencia/glosario.mdx"
      ],
      "files_to_modify": [],
      "files_to_delete": [],
      "proposed_content": "Glosario alfabético: .jsdos bundle (archivo comprimido con juego DOS y configuración para js-dos), ALB (Application Load Balancer de AWS), GitOps (metodología de despliegue usando Git como source of truth), JWT (JSON Web Token para autenticación stateless), Leaderboard (tabla de clasificación de mejores scores), OAuth2 Proxy (proxy de autenticación para GitHub OAuth), Slug (identificador URL-friendly de juego, ej: prince-of-persia).",
      "mermaid_diagram": "",
      "rationale": "Nuevos desarrolladores y stakeholders no técnicos se pierden con términos específicos. Un glosario centralizado reduce malentendidos y acelera onboarding, especialmente útil en documentación externa o presentaciones."
    }
  ],
  "new_sections": [
    {
      "name": "Operaciones y SRE",
      "description": "Sección dedicada a operaciones en producción: monitorización, alertas, incident response, postmortems, capacity planning, oncall procedures",
      "files": [
        {
          "filename": "operaciones/vision-general.mdx",
          "title": "Visión General de Operaciones",
          "content_outline": "Introducción a responsabilidades de operaciones, herramientas principales (Prometheus, Grafana, PagerDuty), equipo oncall, SLIs/SLOs del sistema, enlaces a runbooks y playbooks"
        },
        {
          "filename": "operaciones/runbooks/pod-crashloop.mdx",
          "title": "Runbook: Pod en CrashLoopBackOff",
          "content_outline": "Diagnóstico: kubectl describe pod, logs; causas comunes: imagen incorrecta, secrets faltantes, health check fallido; pasos de resolución; cuándo escalar"
        },
        {
          "filename": "operaciones/runbooks/alta-latencia.mdx",
          "title": "Runbook: Alta Latencia en Respuestas",
          "content_outline": "Identificar servicio afectado en Grafana, revisar métricas DB (query duration, connection pool), revisar traces en Tempo, checkear HPA y CPU throttling, pasos de mitigación"
        },
        {
          "filename": "operaciones/postmortem-template.mdx",
          "title": "Plantilla de Postmortem",
          "content_outline": "Formato estándar para documentar incidentes: resumen ejecutivo, timeline detallado, impacto (usuarios afectados, duración), causa raíz, acciones correctivas, lecciones aprendidas"
        }
      ]
    },
    {
      "name": "Seguridad",
      "description": "Documentación completa de prácticas de seguridad, políticas, procedimientos de respuesta a incidentes, cumplimiento normativo",
      "files": [
        {
          "filename": "seguridad/vision-general.mdx",
          "title": "Visión General de Seguridad",
          "content_outline": "Modelo de seguridad del sistema, principios fundamentales (defensa en profundidad, mínimo privilegio), áreas clave (autenticación, autorización, encriptación, auditoría), responsabilidades del equipo"
        },
        {
          "filename": "seguridad/threat-model.mdx",
          "title": "Modelo de Amenazas",
          "content_outline": "Amenazas identificadas: injection attacks (SQL, XSS), DDoS, credential stuffing, data exfiltration, privileged escalation; mitigaciones implementadas; threat matrix STRIDE"
        },
        {
          "filename": "seguridad/incident-response.mdx",
          "title": "Plan de Respuesta a Incidentes",
          "content_outline": "Procedimiento al detectar incidente: contención, erradicación, recuperación, post-incident review; contactos de emergencia; comunicación con usuarios; evidencia forense"
        },
        {
          "filename": "seguridad/compliance-rgpd.mdx",
          "title": "Cumplimiento RGPD",
          "content_outline": "Datos personales almacenados, bases legales de procesamiento, derechos de usuarios (acceso, rectificación, eliminación, portabilidad), procedimientos para data subject requests, DPO contact"
        }
      ]
    },
    {
      "name": "Arquitectura de Decisiones (ADRs)",
      "description": "Registro de decisiones arquitectónicas importantes tomadas en el proyecto con contexto, alternativas consideradas y consecuencias",
      "files": [
        {
          "filename": "adr/0001-microservicios-vs-monolito.mdx",
          "title": "ADR-0001: Arquitectura de Microservicios",
          "content_outline": "Contexto: necesidad de escalabilidad independiente; Decisión: microservicios por bounded context; Alternativas: monolito modular; Consecuencias: mayor complejidad operacional, mejor aislamiento de fallos"
        },
        {
          "filename": "adr/0002-kubernetes-orchestration.mdx",
          "title": "ADR-0002: Kubernetes como Orquestador",
          "content_outline": "Contexto: necesidad de orquestación de contenedores; Decisión: EKS en AWS; Alternativas: ECS, Fargate, self-managed K8s; Consecuencias: vendor lock-in AWS, ecosistema maduro, soporte enterprise"
        },
        {
          "filename": "adr/0003-postgresql-database.mdx",
          "title": "ADR-0003: PostgreSQL como Base de Datos",
          "content_outline": "Contexto: almacenamiento relacional; Decisión: PostgreSQL en RDS; Alternativas: MySQL, DynamoDB; Consecuencias: ACID completo, JSON support, extensiones (PostGIS futuro), backup automático RDS"
        },
        {
          "filename": "adr/0004-jwt-authentication.mdx",
          "title": "ADR-0004: JWT para Autenticación",
          "content_outline": "Contexto: autenticación stateless; Decisión: JWT con OAuth2; Alternativas: sessions con Redis, API keys; Consecuencias: escalabilidad horizontal, no revocación inmediata, expiry 24h"
        }
      ]
    }
  ],
  "diagrams_needed": [
    {
      "type": "architecture",
      "title": "Vista de Componentes Detallada con Dependencias",
      "description": "Diagrama que muestre todos los microservicios, sus dependencias (base de datos, cache, external APIs), protocolos de comunicación (REST, eventos), y datos que fluyen entre ellos",
      "location": "architecture.mdx",
      "mermaid_code": "graph TB subgraph Frontend F[React App + js-dos] end subgraph API Gateway OP[OAuth2 Proxy] Kong[Kong Gateway] end subgraph Microservicios Auth[Auth Service<br/>Node.js + Express] Game[Game Catalog Service<br/>Node.js + Express] Score[Score Service<br/>Node.js + Express] Rank[Ranking Service<br/>Node.js + Express] User[User Service<br/>Node.js + Express] end subgraph Datos DB[(PostgreSQL RDS<br/>Multi-AZ)] Cache[(Redis ElastiCache<br/>Rankings Cache)] S3[S3 Bucket<br/>Game Assets .jsdos] end subgraph External GH[GitHub OAuth API] end F -->|HTTPS| OP OP --> Kong Kong -->|REST /auth| Auth Kong -->|REST /games| Game Kong -->|REST /scores| Score Kong -->|REST /rankings| Rank Kong -->|REST /users| User Auth --> DB Auth --> GH Game --> DB Game --> S3 Score --> DB Score -.->|Event| Rank Rank --> DB Rank --> Cache User --> DB"
    },
    {
      "type": "flow",
      "title": "Flujo de Despliegue con Rollback Automático",
      "description": "Diagrama de flujo mostrando decision points en pipeline CI/CD: cuándo hacer roll"
    }
  ]
}