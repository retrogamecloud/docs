---
title: "7.2. GitHub Actions"
description: "Workflows automatizados de CI/CD"
icon: "github"
---

## Workflows Implementados

RetroGame Cloud utiliza GitHub Actions para automatizar completamente el ciclo de vida del c√≥digo desde commit hasta producci√≥n.

<CardGroup cols={3}>
  <Card title="docker-publish-and-update-k8s.yml" icon="docker">
    **Pipeline principal CI/CD**

    Build, test, push Docker y actualizar manifiestos K8s
    
    *En todos los servicios*
  </Card>
  
  <Card title="ci.yml" icon="check">
    **Validaci√≥n de manifiestos**

    Tests y validaci√≥n de YAMLs de Kubernetes
    
    *Repo: kubernetes/*
  </Card>
  
  <Card title="update-docs-with-claude.yml" icon="robot">
    **Actualizaci√≥n autom√°tica de docs**

    Claude AI actualiza la wiki/documentaci√≥n
    
    *Repo: docs/*
  </Card>
  
  <Card title="deploy-mintlify-docs.yml" icon="book">
    **Despliegue de documentaci√≥n**

    Deploy autom√°tico a Mintlify
    
    *Repo: docs/*
  </Card>
  
  <Card title="terraform-plan.yml" icon="code">
    **Validaci√≥n de Terraform**

    Plan y validaci√≥n de infraestructura
    
    *Repo: infrastructure/*
  </Card>
  
  <Card title="terraform-apply.yml" icon="rocket">
    **Despliegue de infraestructura**

    Apply de Terraform en producci√≥n
    
    *Repo: infrastructure/*
  </Card>
</CardGroup>

---

## Workflow Principal: Build & Deploy

Este es el workflow que se ejecuta en cada repositorio de servicio (frontend, auth, game-catalog, score, ranking, user).

### Estructura del Workflow

<CodeGroup>

```yaml Configuraci√≥n
name: Compilar, Publicar y Actualizar Kubernetes

on:
  push:
    branches:
      - main
    paths-ignore:
      - '**.md'
      - '.gitignore'
  pull_request:
    branches:
      - main
    paths-ignore:
      - '**.md'
      - '.gitignore'

env:
  REGISTRY_GHCR: ghcr.io
  REGISTRY_DOCKERHUB: docker.io
  IMAGE_NAME: retrogamecloud/frontend  # Cambia por servicio
  K8S_REPO: retrogamecloud/kubernetes
  K8S_MANIFEST_FILE: 04-frontend.yaml  # Cambia por servicio
```

</CodeGroup>

### Job 1: Tests

Ejecuta tests unitarios y de integraci√≥n.

<Steps>
  <Step title="Configurar Entorno">
    ```yaml
    - name: Clonar repositorio
      uses: actions/checkout@v4
    
    - name: Configurar Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'
        cache: 'npm'
    ```
  </Step>
  <Step title="Instalar Dependencias">
    ```yaml
    - name: Instalar dependencias
      run: npm ci
    ```

    Usa `npm ci` en lugar de `npm install` para:

    - Instalaci√≥n m√°s r√°pida
    - Reproducibilidad garantizada
    - Respeta package-lock.json exactamente
  </Step>
  <Step title="Ejecutar Tests">
    ```yaml
    - name: Ejecutar tests
      run: npm test
    
    - name: Generar reporte de cobertura
      run: npm run test:coverage
    ```

    Los tests deben pasar con m√≠nimo 80% de cobertura.
  </Step>
  <Step title="Subir Cobertura">
    ```yaml
    - name: Subir reporte de cobertura
      uses: codecov/codecov-action@v3
      if: always()
      with:
        files: ./coverage/lcov.info
        flags: unittests
        name: frontend-coverage
    ```

    Se ejecuta incluso si los tests fallan (`if: always()`).
  </Step>
</Steps>

### Job 2: Build & Push Docker

Construye y publica la imagen Docker.

<Steps>
  <Step title="Setup Docker">
    ```yaml
    - name: Configurar Docker Buildx
      uses: docker/setup-buildx-action@v3
    ```

    Buildx permite:

    - Multi-platform builds
    - Cache avanzado
    - BuildKit features
  </Step>
  <Step title="Login en Registries">
    ```yaml
    - name: Iniciar sesi√≥n en GitHub Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY_GHCR }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Iniciar sesi√≥n en Docker Hub
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY_DOCKERHUB }}
        username: ${{ secrets.DOCKERHUB_USERNAME }}
        password: ${{ secrets.DOCKERHUB_TOKEN }}
    ```

    Publicamos en dos registries para redundancia.
  </Step>
  <Step title="Generar Versi√≥n">
    ```yaml
    - name: Generar etiqueta de versi√≥n y SHA
      id: version
      run: |
        COMMIT_COUNT=$(git rev-list --count HEAD)
        VERSION="v1.0.${COMMIT_COUNT}"
        SHORT_SHA=$(git rev-parse --short HEAD)
        
        echo "version=${VERSION}" >> $GITHUB_OUTPUT
        echo "short_sha=${SHORT_SHA}" >> $GITHUB_OUTPUT
    ```

    **Versionado sem√°ntico autom√°tico:**

    - `v1.0.1` ‚Üí Primer commit
    - `v1.0.50` ‚Üí Commit n√∫mero 50
    - `sha-a1b2c3d` ‚Üí SHA corto del commit
  </Step>
  <Step title="Build y Push">
    ```yaml
    - name: Compilar y publicar imagen Docker
      uses: docker/build-push-action@v5
      with:
        context: .
        push: true
        tags: |
          retrogamehub/frontend:latest
          retrogamehub/frontend:${{ steps.version.outputs.version }}
          retrogamehub/frontend:sha-${{ steps.version.outputs.short_sha }}
        cache-from: type=registry,ref=ghcr.io/retrogamecloud/frontend:buildcache
        cache-to: type=registry,ref=ghcr.io/retrogamecloud/frontend:buildcache,mode=max
        platforms: linux/amd64
    ```

    **Tres tags por build:**

    1. `latest` - √öltima versi√≥n estable
    2. `v1.0.X` - Versi√≥n espec√≠fica
    3. `sha-XXXXXX` - Commit espec√≠fico
  </Step>
</Steps>

### Job 3: Update Kubernetes Manifest

Actualiza el repositorio GitOps con la nueva imagen.

<Steps>
  <Step title="Clonar Repo Kubernetes">
    ```yaml
    - name: Clonar repositorio de Kubernetes
      uses: actions/checkout@v4
      with:
        repository: ${{ env.K8S_REPO }}
        token: ${{ secrets.K8S_UPDATE_TOKEN }}
        ref: main
    ```

    Usa un Personal Access Token (PAT) con permisos:

    - `repo` (acceso completo)
    - `workflow` (crear PRs)
  </Step>
  <Step title="Actualizar YAML">
    ```yaml
    - name: Actualizar manifiesto de Kubernetes
      run: |
        IMAGE_TAG="sha-${SHORT_SHA}"
        
        sed -i "s|image: retrogamehub/frontend:.*|image: retrogamehub/frontend:${IMAGE_TAG}|g" 04-frontend.yaml
        
        sed -i "s|# Imagen del frontend.*|# Imagen del frontend - ${VERSION} (${IMAGE_TAG})|g" 04-frontend.yaml
    ```

    Usa `sed` para actualizar:

    - La l√≠nea `image:` con el nuevo tag
    - El comentario con la versi√≥n
  </Step>
  <Step title="Crear Pull Request">
    ```yaml
    - name: Crear rama y PR con cambios
      run: |
        BRANCH_NAME="auto/frontend-${IMAGE_TAG}"
        
        git checkout -b "${BRANCH_NAME}"
        git add 04-frontend.yaml
        git commit -m "chore: Actualizar imagen de frontend a ${IMAGE_TAG}"
        git push origin "${BRANCH_NAME}"
        
        gh pr create \
          --repo retrogamecloud/kubernetes \
          --base main \
          --head "${BRANCH_NAME}" \
          --title "chore(frontend): Actualizar a ${IMAGE_TAG}" \
          --body "Version: ${VERSION}, SHA: ${SHORT_SHA}"
      env:
        GH_TOKEN: ${{ secrets.K8S_UPDATE_TOKEN }}
    ```

    Cada despliegue crea un PR autom√°tico con:

    - Rama descriptiva
    - Mensaje de commit estructurado
    - Metadata en el body del PR
  </Step>
</Steps>

## Workflow de Validaci√≥n: Manifiestos K8s

Este workflow valida los manifiestos de Kubernetes en el repositorio `kubernetes/`.

```yaml
name: Kubernetes Manifests CI

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'
    
    - name: Install dependencies
      run: npm install
    
    - name: Run tests
      run: npm test
    
    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v4
      with:
        file: ./coverage/lcov.info

  validate-yamls:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    
    - name: Validate YAML syntax
      run: |
        sudo apt-get install -y yamllint
        yamllint *.yaml

  kubectl-validate:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    
    - name: Setup kubectl
      uses: azure/setup-kubectl@v4
    
    - name: Setup kind
      uses: helm/kind-action@v1.10.0
      with:
        install_only: true
    
    - name: Create kind cluster
      run: kind create cluster
    
    - name: Validate Kubernetes manifests
      run: |
        for file in *.yaml; do
          kubectl apply --dry-run=client -f "$file"
        done
```

**Tres niveles de validaci√≥n:**

1. **Tests unitarios**: Valida estructura de YAMLs
2. **yamllint**: Valida sintaxis YAML
3. **kubectl dry-run**: Valida que sean manifiestos K8s v√°lidos

---

## ü§ñ Workflow: Actualizaci√≥n Autom√°tica de Documentaci√≥n con Claude

Este es el workflow m√°s innovador del proyecto: utiliza **Claude AI** para mantener la documentaci√≥n actualizada autom√°ticamente.

### ¬øQu√© hace?

Cuando se hace un cambio importante en el proyecto (c√≥digo, infraestructura, configuraci√≥n), Claude:
1. üìñ Lee los cambios del commit
2. üîç Analiza qu√© documentaci√≥n necesita actualizarse
3. ‚úçÔ∏è Genera las actualizaciones necesarias
4. üìù Crea un Pull Request con los cambios

### Estructura del Workflow

```yaml
name: Update Documentation with Claude

on:
  workflow_dispatch:  # Manual trigger
    inputs:
      change_description:
        description: 'Descripci√≥n del cambio a documentar'
        required: true
        type: string
      affected_areas:
        description: '√Åreas afectadas (comma-separated): api,infrastructure,deployment'
        required: false
        type: string
  
  repository_dispatch:  # Trigger desde otros repos
    types: [code-change-requires-docs]

jobs:
  update-documentation:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    
    steps:
      - name: Checkout docs repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
      
      - name: Instalar dependencias
        run: |
          npm install --global @anthropic-ai/sdk
          npm install yaml markdown-it
      
      - name: Obtener contexto del cambio
        id: context
        run: |
          # Si es workflow_dispatch, usar inputs
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "description=${{ inputs.change_description }}" >> $GITHUB_OUTPUT
            echo "areas=${{ inputs.affected_areas }}" >> $GITHUB_OUTPUT
          else
            # Si es repository_dispatch, usar payload
            echo "description=${{ github.event.client_payload.description }}" >> $GITHUB_OUTPUT
            echo "areas=${{ github.event.client_payload.areas }}" >> $GITHUB_OUTPUT
            echo "commit_sha=${{ github.event.client_payload.commit_sha }}" >> $GITHUB_OUTPUT
          fi
      
      - name: Llamar a Claude API para generar actualizaciones
        id: claude
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
        run: |
          node .github/scripts/update-docs-with-claude.js \
            --description "${{ steps.context.outputs.description }}" \
            --areas "${{ steps.context.outputs.areas }}" \
            --commit "${{ steps.context.outputs.commit_sha }}"
      
      - name: Crear branch para cambios
        run: |
          BRANCH_NAME="docs/auto-update-$(date +%Y%m%d-%H%M%S)"
          git checkout -b "$BRANCH_NAME"
          echo "branch_name=$BRANCH_NAME" >> $GITHUB_ENV
      
      - name: Commit cambios
        run: |
          git config user.name "Claude Documentation Bot"
          git config user.email "bot@retrogamehub.games"
          
          git add .
          git commit -m "docs: actualizaci√≥n autom√°tica por Claude
          
          Cambio: ${{ steps.context.outputs.description }}
          √Åreas afectadas: ${{ steps.context.outputs.areas }}
          
          Co-authored-by: Claude AI <claude@anthropic.com>"
      
      - name: Push branch
        run: git push origin "${{ env.branch_name }}"
      
      - name: Crear Pull Request
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh pr create \
            --title "üìö docs: Actualizaci√≥n autom√°tica - ${{ steps.context.outputs.description }}" \
            --body "## ü§ñ Actualizaci√≥n Autom√°tica de Documentaci√≥n
          
          Claude AI ha detectado cambios que requieren actualizaci√≥n de documentaci√≥n.
          
          ### Cambio Original
          ${{ steps.context.outputs.description }}
          
          ### √Åreas Afectadas
          ${{ steps.context.outputs.areas }}
          
          ### Archivos Modificados
          $(git diff --name-only HEAD~1)
          
          ### Checklist de Revisi√≥n
          - [ ] Los cambios reflejan correctamente las actualizaciones del c√≥digo
          - [ ] La redacci√≥n es clara y concisa
          - [ ] Los ejemplos de c√≥digo son correctos
          - [ ] Los enlaces internos funcionan
          - [ ] No hay informaci√≥n sensible expuesta
          
          ---
          
          *Generado autom√°ticamente por Claude AI*
          *Revisa y aprueba antes de merge*" \
            --label "documentation,automated" \
            --base main \
            --head "${{ env.branch_name }}"
```

### Script de Claude (update-docs-with-claude.js)

```javascript
// .github/scripts/update-docs-with-claude.js
const Anthropic = require('@anthropic-ai/sdk');
const fs = require('fs').promises;
const path = require('path');
const yaml = require('yaml');

const anthropic = new Anthropic({
  apiKey: process.env.ANTHROPIC_API_KEY,
});

async function main() {
  const args = parseArgs();
  
  // 1. Leer estructura de documentaci√≥n
  const docsStructure = await getDocsStructure();
  
  // 2. Identificar archivos relevantes
  const relevantFiles = await identifyRelevantFiles(args.areas);
  
  // 3. Leer contenido actual
  const currentContent = await readFiles(relevantFiles);
  
  // 4. Llamar a Claude para generar actualizaciones
  const updates = await generateUpdates(
    args.description,
    args.areas,
    currentContent,
    docsStructure
  );
  
  // 5. Aplicar cambios
  await applyUpdates(updates);
  
  console.log('‚úÖ Documentaci√≥n actualizada exitosamente');
}

async function generateUpdates(description, areas, content, structure) {
  const message = await anthropic.messages.create({
    model: 'claude-sonnet-4-20250514',
    max_tokens: 16000,
    temperature: 0.7,
    messages: [{
      role: 'user',
      content: `Eres un experto en documentaci√≥n t√©cnica. 

Cambio realizado:
${description}

√Åreas afectadas: ${areas}

Estructura de documentaci√≥n actual:
${JSON.stringify(structure, null, 2)}

Contenido actual de archivos relevantes:
${JSON.stringify(content, null, 2)}

Genera actualizaciones necesarias para la documentaci√≥n en formato JSON:
{
  "files": [
    {
      "path": "ruta/archivo.mdx",
      "action": "update|create",
      "changes": [
        {
          "section": "nombre de secci√≥n",
          "oldContent": "contenido a reemplazar (si update)",
          "newContent": "nuevo contenido"
        }
      ],
      "reasoning": "por qu√© este cambio es necesario"
    }
  ],
  "summary": "resumen de cambios realizados"
}`
    }]
  });
  
  const response = message.content[0].text;
  return JSON.parse(response);
}

async function applyUpdates(updates) {
  for (const file of updates.files) {
    const filePath = path.join(process.cwd(), file.path);
    
    if (file.action === 'create') {
      // Crear nuevo archivo
      await fs.mkdir(path.dirname(filePath), { recursive: true });
      await fs.writeFile(filePath, file.changes[0].newContent);
      console.log(`‚úÖ Creado: ${file.path}`);
    } else {
      // Actualizar archivo existente
      let content = await fs.readFile(filePath, 'utf-8');
      
      for (const change of file.changes) {
        if (change.oldContent) {
          content = content.replace(change.oldContent, change.newContent);
        } else {
          // A√±adir al final de la secci√≥n
          content += '\n\n' + change.newContent;
        }
      }
      
      await fs.writeFile(filePath, content);
      console.log(`‚úÖ Actualizado: ${file.path}`);
    }
  }
}

// ... m√°s funciones helper ...

main().catch(console.error);
```

### Triggers del Workflow

#### 1. Manual (workflow_dispatch)

```bash
# Desde GitHub UI: Actions ‚Üí Update Documentation ‚Üí Run workflow

# O desde CLI:
gh workflow run update-docs-with-claude.yml \
  -f change_description="A√±adido nuevo endpoint /api/v2/users" \
  -f affected_areas="api,backend"
```

#### 2. Autom√°tico desde otros repos

En el workflow de un servicio:

```yaml
- name: Trigger documentaci√≥n update
  if: github.event_name == 'push' && github.ref == 'refs/heads/main'
  run: |
    curl -X POST \
      -H "Authorization: token ${{ secrets.DOCS_UPDATE_TOKEN }}" \
      -H "Accept: application/vnd.github.v3+json" \
      https://api.github.com/repos/retrogamecloud/docs/dispatches \
      -d '{
        "event_type": "code-change-requires-docs",
        "client_payload": {
          "description": "Nuevo endpoint a√±adido en auth-service",
          "areas": "api,authentication",
          "commit_sha": "${{ github.sha }}",
          "repository": "${{ github.repository }}"
        }
      }'
```

### Ejemplos de Uso

<Tabs>
  <Tab title="Nuevo Endpoint API">
    **Cambio**: A√±adido endpoint `POST /api/auth/refresh-token`
    
    **Claude actualiza**:
    - `api-reference/auth/refresh-token.mdx` (nuevo)
    - `api-reference/auth-service.mdx` (a√±ade referencia)
    - `quickstart.mdx` (actualiza ejemplo de autenticaci√≥n)
    - `CHANGELOG.md` (a√±ade entrada)
  </Tab>
  
  <Tab title="Nueva Variable Terraform">
    **Cambio**: A√±adida variable `enable_waf` en Terraform
    
    **Claude actualiza**:
    - `infrastructure/terraform-variables.mdx` (documenta variable)
    - `deployment.mdx` (menciona en troubleshooting)
    - `quickstart.mdx` (a√±ade a ejemplo de terraform.tfvars)
  </Tab>
  
  <Tab title="Cambio en ArgoCD">
    **Cambio**: Actualizado a ArgoCD v2.10.0
    
    **Claude actualiza**:
    - `infrastructure/argocd-gitops.mdx` (versi√≥n)
    - `CHANGELOG.md` (breaking changes si aplica)
    - `troubleshooting.mdx` (nuevos errores conocidos)
  </Tab>
</Tabs>

### Ventajas del Enfoque

<CardGroup cols={2}>
  <Card title="üöÄ Documentaci√≥n Always Up-to-Date" icon="check">
    La docs nunca se queda desactualizada porque se actualiza autom√°ticamente con cada cambio
  </Card>
  
  <Card title="‚è∞ Ahorro de Tiempo" icon="clock">
    Los developers no pierden tiempo actualizando docs manualmente
  </Card>
  
  <Card title="üéØ Consistencia" icon="target">
    Claude mantiene un estilo y estructura consistente en toda la documentaci√≥n
  </Card>
  
  <Card title="üîç Cobertura Completa" icon="magnifying-glass">
    Claude identifica todas las √°reas que necesitan actualizaci√≥n, no solo las obvias
  </Card>
</CardGroup>

### Configuraci√≥n Necesaria

<Steps>
  <Step title="Obtener API Key de Anthropic">
    ```bash
    # 1. Ir a https://console.anthropic.com/
    # 2. Crear API Key
    # 3. Copiar el key (sk-ant-...)
    ```
  </Step>
  
  <Step title="A√±adir Secret en GitHub">
    ```bash
    # Repo: docs
    # Settings ‚Üí Secrets ‚Üí Actions ‚Üí New repository secret
    # Name: ANTHROPIC_API_KEY
    # Value: sk-ant-...
    ```
  </Step>
  
  <Step title="Configurar Permisos">
    ```yaml
    # En el workflow
    permissions:
      contents: write      # Para crear branches
      pull-requests: write # Para crear PRs
    ```
  </Step>
  
  <Step title="Crear Script">
    ```bash
    mkdir -p .github/scripts
    # Copiar update-docs-with-claude.js
    chmod +x .github/scripts/update-docs-with-claude.js
    ```
  </Step>
</Steps>

### Costos Estimados

<Table>
  <thead>
    <tr>
      <th>M√©trica</th>
      <th>Valor</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>**Tokens por actualizaci√≥n**</td>
      <td>~8,000 input + 4,000 output</td>
    </tr>
    <tr>
      <td>**Costo por actualizaci√≥n**</td>
      <td>~$0.15 (Claude Sonnet 4)</td>
    </tr>
    <tr>
      <td>**Actualizaciones/mes**</td>
      <td>~20-30</td>
    </tr>
    <tr>
      <td>**Costo mensual total**</td>
      <td>**~$3-5/mes**</td>
    </tr>
  </tbody>
</Table>

<Note>
  El costo es m√≠nimo comparado con el tiempo ahorrado (20-30 horas/mes de documentaci√≥n manual).
</Note>

---

## üìö Workflow: Despliegue de Documentaci√≥n a Mintlify

Despliega autom√°ticamente la documentaci√≥n a Mintlify cuando hay cambios.

```yaml
name: Deploy to Mintlify

on:
  push:
    branches:
      - main
    paths:
      - '**.mdx'
      - '**.md'
      - 'mint.json'
      - 'images/**'

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Deploy to Mintlify
        uses: mintlify/action@v1
        with:
          mintlify-api-key: ${{ secrets.MINTLIFY_API_KEY }}
          
      - name: Notify on Slack
        if: success()
        run: |
          curl -X POST ${{ secrets.SLACK_WEBHOOK }} \
            -H 'Content-Type: application/json' \
            -d '{
              "text": "‚úÖ Documentaci√≥n desplegada: https://docs.retrogamehub.games"
            }'
```

**Trigger**: Cualquier cambio en archivos `.mdx`, `.md` o `mint.json`

**Duraci√≥n**: ~1-2 minutos

---

## üèóÔ∏è Workflow: Validaci√≥n de Terraform

Valida cambios en infraestructura antes de aplicarlos.

```yaml
name: Terraform Plan

on:
  pull_request:
    branches:
      - main
    paths:
      - 'terraform/**'
      - '**.tf'

jobs:
  terraform-plan:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: terraform/eks_test
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.6
      
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: eu-west-1
      
      - name: Terraform Format Check
        run: terraform fmt -check -recursive
      
      - name: Terraform Init
        run: terraform init
      
      - name: Terraform Validate
        run: terraform validate
      
      - name: Terraform Plan
        id: plan
        run: |
          terraform plan -no-color -out=tfplan
          terraform show -no-color tfplan > plan_output.txt
      
      - name: Comment Plan on PR
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const plan = fs.readFileSync('terraform/eks_test/plan_output.txt', 'utf8');
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `## Terraform Plan
              
              \`\`\`terraform
              ${plan.slice(0, 65000)}
              \`\`\`
              
              [Ver plan completo en Actions](${context.payload.pull_request.html_url}/checks)`
            });
      
      - name: Check for Destructive Changes
        run: |
          if grep -q "destroy" plan_output.txt; then
            echo "‚ö†Ô∏è ADVERTENCIA: El plan incluye recursos a DESTRUIR"
            echo "destructive=true" >> $GITHUB_ENV
          fi
      
      - name: Upload Plan Artifact
        uses: actions/upload-artifact@v4
        with:
          name: terraform-plan
          path: terraform/eks_test/tfplan
```

**Caracter√≠sticas**:
- ‚úÖ Valida formato de Terraform
- ‚úÖ Ejecuta `terraform plan`
- ‚úÖ Comenta el plan en el PR
- ‚úÖ Detecta cambios destructivos
- ‚úÖ Guarda plan para aplicar despu√©s

---

## üöÄ Workflow: Aplicar Terraform

Aplica cambios de infraestructura en producci√≥n (manual trigger).

```yaml
name: Terraform Apply

on:
  workflow_dispatch:
    inputs:
      confirm:
        description: 'Type "apply" to confirm'
        required: true
        type: string

jobs:
  terraform-apply:
    runs-on: ubuntu-latest
    if: github.event.inputs.confirm == 'apply'
    defaults:
      run:
        working-directory: terraform/eks_test
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
      
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: eu-west-1
      
      - name: Terraform Init
        run: terraform init
      
      - name: Terraform Apply
        run: terraform apply -auto-approve
      
      - name: Save Outputs
        run: terraform output -json > terraform-outputs.json
      
      - name: Upload Outputs
        uses: actions/upload-artifact@v4
        with:
          name: terraform-outputs
          path: terraform/eks_test/terraform-outputs.json
      
      - name: Notify on Slack
        if: always()
        run: |
          STATUS="${{ job.status }}"
          
          if [ "$STATUS" == "success" ]; then
            ICON="‚úÖ"
            COLOR="good"
          else
            ICON="‚ùå"
            COLOR="danger"
          fi
          
          curl -X POST ${{ secrets.SLACK_WEBHOOK }} \
            -H 'Content-Type: application/json' \
            -d "{
              \"attachments\": [{
                \"color\": \"$COLOR\",
                \"title\": \"$ICON Terraform Apply - $STATUS\",
                \"text\": \"Infraestructura actualizada en producci√≥n\",
                \"fields\": [
                  {
                    \"title\": \"Ejecutado por\",
                    \"value\": \"${{ github.actor }}\",
                    \"short\": true
                  },
                  {
                    \"title\": \"Commit\",
                    \"value\": \"${{ github.sha }}\",
                    \"short\": true
                  }
                ]
              }]
            }"
```

**Seguridad**:
- ‚ö†Ô∏è Solo manual trigger
- ‚ö†Ô∏è Requiere confirmaci√≥n expl√≠cita
- ‚ö†Ô∏è Notifica en Slack
- ‚ö†Ô∏è Guarda outputs para auditor√≠a

---

## üöÄ Mejoras Inteligentes del Workflow (2025)

El workflow de an√°lisis inteligente ha sido **potenciado con 5 nuevas capacidades autom√°ticas** que lo hacen mucho m√°s eficiente y completo:

### 1. ‚ö° Auto-fix de Quick Wins

Aplica **autom√°ticamente** correcciones simples sin necesidad de review humano:

<CardGroup cols={2}>
  <Card title="‚ú® Iconos en Frontmatter" icon="icons">
    A√±ade iconos apropiados a archivos que no los tienen
  </Card>
  
  <Card title="üìù Descripciones Generadas" icon="file-lines">
    Genera descriptions autom√°ticas basadas en t√≠tulos
  </Card>
  
  <Card title="üìê Formato Estandarizado" icon="align-left">
    Corrige espaciado de encabezados, listas y c√≥digo
  </Card>
  
  <Card title="üî§ T√≠tulos Normalizados" icon="heading">
    Estandariza capitalizaci√≥n y formato de t√≠tulos
  </Card>
</CardGroup>

```python
# Ejemplo de correcci√≥n autom√°tica
# ANTES:
---
title:introducci√≥n al sistema
---

# DESPU√âS:
---
title: Introducci√≥n al Sistema
description: Documentaci√≥n sobre Introducci√≥n al Sistema
icon: book-open
---
```

**Ahorro de tiempo**: ~2-3 horas/semana en correcciones manuales

---

### 2. üîÑ An√°lisis Incremental con Cache

Sistema inteligente de cache que **reduce costos en 80-90%**:

<Steps>
  <Step title="Cache SHA256">
    Calcula hash de cada archivo para detectar cambios reales
  </Step>
  
  <Step title="Detecci√≥n Git">
    Integra con `git diff` para ver archivos modificados
  </Step>
  
  <Step title="An√°lisis Selectivo">
    Solo analiza archivos que cambiaron desde √∫ltimo an√°lisis
  </Step>
  
  <Step title="Full Analysis Programado">
    An√°lisis completo autom√°tico 1x/semana
  </Step>
</Steps>

```bash
# Ejemplo de output
üîÑ An√°lisis INCREMENTAL
   üìù Cambios por git: 3 archivos
   üîí Cambios por hash: 2 archivos
   ‚ö° Total a analizar: 5/50 archivos
   üí∞ Ahorro: 90% en tokens/costos
```

**Reducci√≥n de costos**: De ~$20/mes a ~$3-5/mes

---

### 3. üîó Validaci√≥n de Links

Verifica **todos los links** en la documentaci√≥n autom√°ticamente:

<Accordion title="Links Internos">
  - Verifica que archivos `.mdx` existan
  - Resuelve paths relativos y absolutos
  - Detecta links rotos entre secciones
  - Valida anchors dentro de p√°ginas
</Accordion>

<Accordion title="Links Externos">
  - Hace requests HTTP HEAD/GET
  - Rate limiting configurable (0.5s por defecto)
  - Cache de URLs ya verificadas
  - Timeout de 10 segundos
</Accordion>

<Accordion title="Im√°genes y Assets">
  - Verifica que im√°genes existan
  - Valida CSS y JavaScript externos
  - Detecta assets rotos
  - Soporte para URLs remotas
</Accordion>

```markdown
# Reporte generado: BROKEN_LINKS_REPORT.md

## üîó Links Rotos Encontrados

### üìÑ Links Internos (2)
- `api-reference/auth.mdx`: `/api/old-endpoint.mdx` ‚Üí Archivo no encontrado

### üåê Links Externos (1)
- `infrastructure/overview.mdx`: `https://old-domain.com` ‚Üí HTTP 404

### üñºÔ∏è Im√°genes (1)
- `quickstart.mdx`: `/images/screenshot-old.png` ‚Üí Imagen no encontrada
```

---

### 4. üìù An√°lisis de C√≥digo con AST

Parser autom√°tico de c√≥digo fuente para detectar **APIs no documentadas**:

<Tabs>
  <Tab title="Python">
    ```python
    # Detecta:
    - Funciones y clases p√∫blicas sin docstrings
    - Endpoints Flask/FastAPI sin documentar
    - Par√°metros de funciones
    - Decoradores aplicados
    
    # Ejemplo:
    @app.route('/api/users', methods=['POST'])
    def create_user(username, email):  # ‚ö†Ô∏è Sin docstring
        pass
    
    # Generar√° reporte:
    - Endpoint: POST /api/users
    - Archivo: services/user_service.py:45
    - Par√°metros: username, email
    - Estado: ‚ö†Ô∏è Sin documentar
    ```
  </Tab>
  
  <Tab title="JavaScript/TypeScript">
    ```javascript
    // Detecta:
    - Exports sin JSDoc
    - Endpoints Express/Fastify
    - Funciones arrow exportadas
    - Clases y m√©todos p√∫blicos
    
    // Ejemplo:
    export function validateToken(token) {  // ‚ö†Ô∏è Sin JSDoc
      return jwt.verify(token, SECRET);
    }
    
    // Generar√° reporte:
    - Funci√≥n: validateToken
    - Archivo: utils/auth.js:12
    - Par√°metros: token
    - Estado: ‚ö†Ô∏è Sin documentar
    ```
  </Tab>
</Tabs>

**Cobertura de documentaci√≥n**: El script genera un score de cobertura (ej: 87.5%)

---

### 5. üé® Generaci√≥n Autom√°tica de Diagramas

Crea diagramas Mermaid **desde el c√≥digo fuente** autom√°ticamente:

<CardGroup cols={2}>
  <Card title="üîÑ Sequence Diagrams" icon="diagram-project">
    Desde endpoints de API detecta flujos de ejecuci√≥n
  </Card>
  
  <Card title="üèóÔ∏è Architecture Diagrams" icon="sitemap">
    Desde docker-compose.yml genera arquitectura de servicios
  </Card>
  
  <Card title="üìä Flow Diagrams" icon="diagram-next">
    Desde GitHub Actions workflows genera flujos CI/CD
  </Card>
  
  <Card title="üìê Component Diagrams" icon="cubes">
    Desde estructura de repos genera diagrama de componentes
  </Card>
</CardGroup>

```yaml
# Ejemplo: De docker-compose.yml a diagrama
services:
  backend:
    depends_on: [postgres, redis]
  kong:
    depends_on: [backend]

# Genera autom√°ticamente:
```mermaid
graph TB
    backend[Backend Service]
    kong[API Gateway]
    postgres[(PostgreSQL)]
    redis[[Redis Cache]]
    
    backend --> postgres
    backend --> redis
    kong --> backend
```

Los diagramas se **insertan autom√°ticamente** en archivos `.mdx` relevantes.

---

## üìä Impacto de las Mejoras

<Table>
  <thead>
    <tr>
      <th>M√©trica</th>
      <th>Antes</th>
      <th>Despu√©s</th>
      <th>Mejora</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>**Tiempo de ejecuci√≥n**</td>
      <td>~15 min</td>
      <td>~5 min</td>
      <td>üü¢ 67% m√°s r√°pido</td>
    </tr>
    <tr>
      <td>**Costo mensual**</td>
      <td>~$20</td>
      <td>~$3-5</td>
      <td>üü¢ 80% reducci√≥n</td>
    </tr>
    <tr>
      <td>**Correcciones manuales**</td>
      <td>2-3 h/semana</td>
      <td>0 h</td>
      <td>üü¢ 100% automatizado</td>
    </tr>
    <tr>
      <td>**Links rotos detectados**</td>
      <td>Manual</td>
      <td>Autom√°tico</td>
      <td>üü¢ 100% cobertura</td>
    </tr>
    <tr>
      <td>**APIs documentadas**</td>
      <td>~70%</td>
      <td>Tracking 100%</td>
      <td>üü¢ Visibilidad total</td>
    </tr>
    <tr>
      <td>**Diagramas actualizados**</td>
      <td>Manual</td>
      <td>Autom√°tico</td>
      <td>üü¢ Siempre actuales</td>
    </tr>
  </tbody>
</Table>

---

## ‚öôÔ∏è Configuraci√≥n del Workflow Mejorado

### Secrets Requeridos

```bash
# GitHub Secrets necesarios:
ANTHROPIC_API_KEY=sk-ant-...  # API key de Claude
PAT_TOKEN=ghp_...             # Personal Access Token con permisos
```

### Ejecuci√≥n Manual

```bash
# Desde GitHub UI
Actions ‚Üí Daily Documentation Analysis ‚Üí Run workflow

# Opciones:
- analysis_depth: quick | full | deep
- reorganize_structure: true | false

# Desde CLI:
gh workflow run intelligent-docs-review.yml \
  -f analysis_depth=full \
  -f reorganize_structure=true
```

### Flujo Completo

```mermaid
flowchart TD
    Start([Trigger Manual/Diario])
    Start --> Clone[Clonar Repos]
    Clone --> AutoFix[1. Auto-fix Quick Wins]
    AutoFix --> Links[2. Validar Links]
    Links --> AST[3. Analizar C√≥digo AST]
    AST --> Diagrams[4. Generar Diagramas]
    Diagrams --> Cache[5. Check Cache]
    
    Cache -->|Full Needed| Analyze[6. An√°lisis Claude]
    Cache -->|Incremental| Skip[Skip An√°lisis]
    
    Analyze --> Reorganize[7. Reorganizar docs.json]
    Skip --> Reorganize
    
    Reorganize --> PR[8. Crear PR]
    PR --> End([Fin])
    
    style AutoFix fill:#90EE90
    style Links fill:#87CEEB
    style AST fill:#FFB6C1
    style Diagrams fill:#DDA0DD
    style Cache fill:#F0E68C
```

---

## üéØ Pr√≥ximas Mejoras Planeadas

<Note>
  Las siguientes capacidades est√°n en el roadmap para 2025:
</Note>

1. **M√©tricas de Uso**: Integraci√≥n con Mintlify analytics para priorizar mejoras
2. **GitHub Issues Automation**: Crear issues autom√°ticamente para critical gaps
3. **Comparaci√≥n con Best Practices**: Benchmark contra docs de Stripe, Twilio, AWS
4. **Multi-idioma**: Detectar t√©rminos sin traducir y generar glosario
5. **Feedback Loop**: Integrar comentarios de PRs y issues en an√°lisis

---

## Configuraci√≥n de Secrets

### En Repositorios de Servicios

<Steps>
  <Step title="Ir a Settings">
    `https://github.com/retrogamecloud/<repo>/settings/secrets/actions`
  </Step>
  <Step title="Agregar Secrets">
    <Table>
  <thead>
    <tr>
      <th>Secret</th>
      <th>Valor</th>
      <th>Uso</th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>`DOCKERHUB_USERNAME`</td>
      <td>Tu usuario de Docker Hub</td>
      <td>Login en Docker Hub</td>
    </tr>

    <tr>
      <td>`DOCKERHUB_TOKEN`</td>
      <td>Access Token de Docker Hub</td>
      <td>Autenticaci√≥n (no usar password)</td>
    </tr>

    <tr>
      <td>`K8S_UPDATE_TOKEN`</td>
      <td>GitHub PAT</td>
      <td>Actualizar repo kubernetes/</td>
    </tr>

    <tr>
      <td>`CODECOV_TOKEN`</td>
      <td>Token de Codecov</td>
      <td>Subir cobertura (opcional)</td>
    </tr>
  </tbody>
</Table>
  </Step>
</Steps>

### Generar Docker Hub Token

```bash
# 1. Ir a https://hub.docker.com/settings/security
# 2. Click en "New Access Token"
# 3. Descripci√≥n: "GitHub Actions - RetroGame"
# 4. Permisos: Read & Write
# 5. Copiar el token (solo se muestra una vez)
```

### Generar GitHub PAT

```bash
# 1. Ir a https://github.com/settings/tokens
# 2. Click en "Generate new token (classic)"
# 3. Descripci√≥n: "K8s Manifest Updates"
# 4. Scopes:
#    - repo (todo)
#    - workflow
# 5. Copiar el token
```

## Variables de Entorno por Servicio

Cada servicio necesita personalizar estas variables en el workflow:

<CodeGroup>

```yaml Frontend
env:
  IMAGE_NAME: retrogamecloud/frontend
  K8S_MANIFEST_FILE: 04-frontend.yaml
```


```yaml Auth Service
env:
  IMAGE_NAME: retrogamecloud/auth-service
  K8S_MANIFEST_FILE: 06-auth-service.yaml
```


```yaml Game Catalog
env:
  IMAGE_NAME: retrogamecloud/game-catalog-service
  K8S_MANIFEST_FILE: 07-game-catalog.yaml
```

</CodeGroup>

## Optimizaciones del Pipeline

### 1. Cache de Dependencias

```yaml
- name: Configurar Node.js
  uses: actions/setup-node@v4
  with:
    node-version: '20'
    cache: 'npm'  # Cachea node_modules
```

**Beneficio**: Tests 2-3x m√°s r√°pidos (1 min ‚Üí 20s)

### 2. Docker Build Cache

```yaml
cache-from: type=registry,ref=ghcr.io/.../buildcache
cache-to: type=registry,ref=ghcr.io/.../buildcache,mode=max
```

**Beneficio**: Builds 3-5x m√°s r√°pidos (5 min ‚Üí 1-2 min)

### 3. Conditional Jobs

```yaml
jobs:
  build-and-push:
    needs: test  # Solo ejecuta si tests pasan
    if: github.event_name == 'push'  # Solo en push, no en PR
```

**Beneficio**: Ahorra minutos de CI cuando tests fallan

### 4. Path Filters

```yaml
on:
  push:
    paths-ignore:
      - '**.md'
      - '.gitignore'
```

**Beneficio**: No ejecuta pipeline en cambios de documentaci√≥n

## Monitoreo y Debugging

### Ver Logs en Tiempo Real

```bash
# Usando GitHub CLI
gh run watch

# Ver logs de un job espec√≠fico
gh run view --log

# Lista de runs recientes
gh run list --limit 10
```

### Debugging con SSH (Emergencias)

Agrega este step temporalmente:

```yaml
- name: Setup tmate session
  uses: mxschmitt/action-tmate@v3
  if: failure()  # Solo si el job falla
```

Esto te da acceso SSH al runner para debugging.

## M√©tricas del Pipeline

<CardGroup cols={2}>
  <Card title="Tiempo Promedio" icon="clock">
    **6 minutos**

    - Tests: 1-2 min
    - Build: 2-3 min
    - Push & Update: 1-2 min
  </Card>
  <Card title="Tasa de √âxito" icon="chart-line">
    **94.5%**

    Basado en √∫ltimos 100 runs
  </Card>
  <Card title="Ejecuciones/D√≠a" icon="calendar">
    **~15 runs**

    Promedio entre todos los servicios
  </Card>
  <Card title="Costo Mensual" icon="dollar-sign">
    **\$0 (gratis)**

    GitHub Actions es gratis para repos p√∫blicos
  </Card>
</CardGroup>

## Best Practices Implementadas

<AccordionGroup>
  <Accordion title="‚úÖ Jobs Independientes">
    Cada job puede fallar independientemente. Si los tests fallan, no se ejecuta el build.
  </Accordion>
  <Accordion title="‚úÖ Fail Fast">
    El pipeline se detiene al primer error. No desperdicia tiempo en builds que fallar√°n.
  </Accordion>
  <Accordion title="‚úÖ Immutable Tags">
    Cada build tiene un tag √∫nico basado en el SHA del commit. Nunca se sobreescribe.
  </Accordion>
  <Accordion title="‚úÖ Audit Trail">
    Cada despliegue genera un PR con metadata completa. Historial completo en Git.
  </Accordion>
  <Accordion title="‚úÖ Security Scanning">
    Docker Scout escanea vulnerabilidades en cada imagen antes del push.
  </Accordion>
</AccordionGroup>

## Troubleshooting

<AccordionGroup>
  <Accordion title="Error: Docker login failed">
    **Causa**: Token de Docker Hub inv√°lido o expirado

    **Soluci√≥n**:

    ```bash
    # Generar nuevo token en Docker Hub
    # Actualizar secret DOCKERHUB_TOKEN en GitHub
    ```
  </Accordion>
  <Accordion title="Error: Tests failing">
    **Causa**: Tests no pasan localmente tampoco

    **Soluci√≥n**:

    ```bash
    # Ejecutar tests localmente primero
    npm test
    npm run test:coverage
    
    # Fix tests antes de push
    ```
  </Accordion>
  <Accordion title="Error: Permission denied updating K8s repo">
    **Causa**: PAT sin permisos suficientes

    **Soluci√≥n**:

    - Verificar que el PAT tenga scope `repo` y `workflow`
    - Regenerar PAT si es necesario
    - Actualizar secret `K8S_UPDATE_TOKEN`
  </Accordion>
  <Accordion title="Workflow no se ejecuta">
    **Causa**: Cambios solo en archivos ignorados (\*.md)

    **Soluci√≥n**: Normal. El workflow solo se ejecuta en cambios de c√≥digo.
  </Accordion>
</AccordionGroup>

## Pr√≥ximos Pasos

<CardGroup cols={2}>
  <Card title="GitOps Workflow" icon="code-branch" href="/cicd/gitops-workflow">
    Flujo completo de GitOps
  </Card>
  <Card title="CI/CD Overview" icon="rocket" href="/cicd/overview">
    Visi√≥n general del pipeline
  </Card>
  <Card title="Monitoreo" icon="chart-line" href="/infrastructure/monitoring">
    Observabilidad del sistema
  </Card>
  <Card title="Infraestructura" icon="server" href="/infrastructure/overview">
    Setup de AWS y Kubernetes
  </Card>
</CardGroup>