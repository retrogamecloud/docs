---
title: "7.2. GitHub Actions"
description: "Workflows automatizados de CI/CD"
icon: "github"
---

## Workflows Implementados

RetroGame Cloud utiliza GitHub Actions para automatizar completamente el ciclo de vida del código desde commit hasta producción.

<CardGroup cols={2}>
  <Card title="docker-publish-and-update-k8s.yml" icon="docker">
    **Pipeline principal**

    Build, test, push y actualizar manifiestos K8s
  </Card>
  <Card title="ci.yml" icon="check">
    **Validación de manifiestos**

    Tests y validación de YAMLs de Kubernetes
  </Card>
</CardGroup>

## Workflow Principal: Build & Deploy

Este es el workflow que se ejecuta en cada repositorio de servicio (frontend, auth, game-catalog, score, ranking, user).

### Estructura del Workflow

<CodeGroup>

```yaml Configuración
name: Compilar, Publicar y Actualizar Kubernetes

on:
  push:
    branches:
      - main
    paths-ignore:
      - '**.md'
      - '.gitignore'
  pull_request:
    branches:
      - main
    paths-ignore:
      - '**.md'
      - '.gitignore'

env:
  REGISTRY_GHCR: ghcr.io
  REGISTRY_DOCKERHUB: docker.io
  IMAGE_NAME: retrogamecloud/frontend  # Cambia por servicio
  K8S_REPO: retrogamecloud/kubernetes
  K8S_MANIFEST_FILE: 04-frontend.yaml  # Cambia por servicio
```

</CodeGroup>

### Job 1: Tests

Ejecuta tests unitarios y de integración.

<Steps>
  <Step title="Configurar Entorno">
    ```yaml
    - name: Clonar repositorio
      uses: actions/checkout@v4
    
    - name: Configurar Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'
        cache: 'npm'
    ```
  </Step>
  <Step title="Instalar Dependencias">
    ```yaml
    - name: Instalar dependencias
      run: npm ci
    ```

    Usa `npm ci` en lugar de `npm install` para:

    - Instalación más rápida
    - Reproducibilidad garantizada
    - Respeta package-lock.json exactamente
  </Step>
  <Step title="Ejecutar Tests">
    ```yaml
    - name: Ejecutar tests
      run: npm test
    
    - name: Generar reporte de cobertura
      run: npm run test:coverage
    ```

    Los tests deben pasar con mínimo 80% de cobertura.
  </Step>
  <Step title="Subir Cobertura">
    ```yaml
    - name: Subir reporte de cobertura
      uses: codecov/codecov-action@v3
      if: always()
      with:
        files: ./coverage/lcov.info
        flags: unittests
        name: frontend-coverage
    ```

    Se ejecuta incluso si los tests fallan (`if: always()`).
  </Step>
</Steps>

### Job 2: Build & Push Docker

Construye y publica la imagen Docker.

<Steps>
  <Step title="Setup Docker">
    ```yaml
    - name: Configurar Docker Buildx
      uses: docker/setup-buildx-action@v3
    ```

    Buildx permite:

    - Multi-platform builds
    - Cache avanzado
    - BuildKit features
  </Step>
  <Step title="Login en Registries">
    ```yaml
    - name: Iniciar sesión en GitHub Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY_GHCR }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Iniciar sesión en Docker Hub
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY_DOCKERHUB }}
        username: ${{ secrets.DOCKERHUB_USERNAME }}
        password: ${{ secrets.DOCKERHUB_TOKEN }}
    ```

    Publicamos en dos registries para redundancia.
  </Step>
  <Step title="Generar Versión">
    ```yaml
    - name: Generar etiqueta de versión y SHA
      id: version
      run: |
        COMMIT_COUNT=$(git rev-list --count HEAD)
        VERSION="v1.0.${COMMIT_COUNT}"
        SHORT_SHA=$(git rev-parse --short HEAD)
        
        echo "version=${VERSION}" >> $GITHUB_OUTPUT
        echo "short_sha=${SHORT_SHA}" >> $GITHUB_OUTPUT
    ```

    **Versionado semántico automático:**

    - `v1.0.1` → Primer commit
    - `v1.0.50` → Commit número 50
    - `sha-a1b2c3d` → SHA corto del commit
  </Step>
  <Step title="Build y Push">
    ```yaml
    - name: Compilar y publicar imagen Docker
      uses: docker/build-push-action@v5
      with:
        context: .
        push: true
        tags: |
          retrogamehub/frontend:latest
          retrogamehub/frontend:${{ steps.version.outputs.version }}
          retrogamehub/frontend:sha-${{ steps.version.outputs.short_sha }}
        cache-from: type=registry,ref=ghcr.io/retrogamecloud/frontend:buildcache
        cache-to: type=registry,ref=ghcr.io/retrogamecloud/frontend:buildcache,mode=max
        platforms: linux/amd64
    ```

    **Tres tags por build:**

    1. `latest` - Última versión estable
    2. `v1.0.X` - Versión específica
    3. `sha-XXXXXX` - Commit específico
  </Step>
</Steps>

### Job 3: Update Kubernetes Manifest

Actualiza el repositorio GitOps con la nueva imagen.

<Steps>
  <Step title="Clonar Repo Kubernetes">
    ```yaml
    - name: Clonar repositorio de Kubernetes
      uses: actions/checkout@v4
      with:
        repository: ${{ env.K8S_REPO }}
        token: ${{ secrets.K8S_UPDATE_TOKEN }}
        ref: main
    ```

    Usa un Personal Access Token (PAT) con permisos:

    - `repo` (acceso completo)
    - `workflow` (crear PRs)
  </Step>
  <Step title="Actualizar YAML">
    ```yaml
    - name: Actualizar manifiesto de Kubernetes
      run: |
        IMAGE_TAG="sha-${SHORT_SHA}"
        
        sed -i "s|image: retrogamehub/frontend:.*|image: retrogamehub/frontend:${IMAGE_TAG}|g" 04-frontend.yaml
        
        sed -i "s|# Imagen del frontend.*|# Imagen del frontend - ${VERSION} (${IMAGE_TAG})|g" 04-frontend.yaml
    ```

    Usa `sed` para actualizar:

    - La línea `image:` con el nuevo tag
    - El comentario con la versión
  </Step>
  <Step title="Crear Pull Request">
    ```yaml
    - name: Crear rama y PR con cambios
      run: |
        BRANCH_NAME="auto/frontend-${IMAGE_TAG}"
        
        git checkout -b "${BRANCH_NAME}"
        git add 04-frontend.yaml
        git commit -m "chore: Actualizar imagen de frontend a ${IMAGE_TAG}"
        git push origin "${BRANCH_NAME}"
        
        gh pr create \
          --repo retrogamecloud/kubernetes \
          --base main \
          --head "${BRANCH_NAME}" \
          --title "chore(frontend): Actualizar a ${IMAGE_TAG}" \
          --body "Version: ${VERSION}, SHA: ${SHORT_SHA}"
      env:
        GH_TOKEN: ${{ secrets.K8S_UPDATE_TOKEN }}
    ```

    Cada despliegue crea un PR automático con:

    - Rama descriptiva
    - Mensaje de commit estructurado
    - Metadata en el body del PR
  </Step>
</Steps>

## Workflow de Validación: Manifiestos K8s

Este workflow valida los manifiestos de Kubernetes en el repositorio `kubernetes/`.

```yaml
name: Kubernetes Manifests CI

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'
    
    - name: Install dependencies
      run: npm install
    
    - name: Run tests
      run: npm test
    
    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v4
      with:
        file: ./coverage/lcov.info

  validate-yamls:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    
    - name: Validate YAML syntax
      run: |
        sudo apt-get install -y yamllint
        yamllint *.yaml

  kubectl-validate:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    
    - name: Setup kubectl
      uses: azure/setup-kubectl@v4
    
    - name: Setup kind
      uses: helm/kind-action@v1.10.0
      with:
        install_only: true
    
    - name: Create kind cluster
      run: kind create cluster
    
    - name: Validate Kubernetes manifests
      run: |
        for file in *.yaml; do
          kubectl apply --dry-run=client -f "$file"
        done
```

**Tres niveles de validación:**

1. **Tests unitarios**: Valida estructura de YAMLs
2. **yamllint**: Valida sintaxis YAML
3. **kubectl dry-run**: Valida que sean manifiestos K8s válidos

## Configuración de Secrets

### En Repositorios de Servicios

<Steps>
  <Step title="Ir a Settings">
    `https://github.com/retrogamecloud/<repo>/settings/secrets/actions`
  </Step>
  <Step title="Agregar Secrets">
    <Table>
  <thead>
    <tr>
      <th>Secret</th>
      <th>Valor</th>
      <th>Uso</th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>`DOCKERHUB_USERNAME`</td>
      <td>Tu usuario de Docker Hub</td>
      <td>Login en Docker Hub</td>
    </tr>

    <tr>
      <td>`DOCKERHUB_TOKEN`</td>
      <td>Access Token de Docker Hub</td>
      <td>Autenticación (no usar password)</td>
    </tr>

    <tr>
      <td>`K8S_UPDATE_TOKEN`</td>
      <td>GitHub PAT</td>
      <td>Actualizar repo kubernetes/</td>
    </tr>

    <tr>
      <td>`CODECOV_TOKEN`</td>
      <td>Token de Codecov</td>
      <td>Subir cobertura (opcional)</td>
    </tr>
  </tbody>
</Table>
  </Step>
</Steps>

### Generar Docker Hub Token

```bash
# 1. Ir a https://hub.docker.com/settings/security
# 2. Click en "New Access Token"
# 3. Descripción: "GitHub Actions - RetroGame"
# 4. Permisos: Read & Write
# 5. Copiar el token (solo se muestra una vez)
```

### Generar GitHub PAT

```bash
# 1. Ir a https://github.com/settings/tokens
# 2. Click en "Generate new token (classic)"
# 3. Descripción: "K8s Manifest Updates"
# 4. Scopes:
#    - repo (todo)
#    - workflow
# 5. Copiar el token
```

## Variables de Entorno por Servicio

Cada servicio necesita personalizar estas variables en el workflow:

<CodeGroup>

```yaml Frontend
env:
  IMAGE_NAME: retrogamecloud/frontend
  K8S_MANIFEST_FILE: 04-frontend.yaml
```


```yaml Auth Service
env:
  IMAGE_NAME: retrogamecloud/auth-service
  K8S_MANIFEST_FILE: 06-auth-service.yaml
```


```yaml Game Catalog
env:
  IMAGE_NAME: retrogamecloud/game-catalog-service
  K8S_MANIFEST_FILE: 07-game-catalog.yaml
```

</CodeGroup>

## Optimizaciones del Pipeline

### 1. Cache de Dependencias

```yaml
- name: Configurar Node.js
  uses: actions/setup-node@v4
  with:
    node-version: '20'
    cache: 'npm'  # Cachea node_modules
```

**Beneficio**: Tests 2-3x más rápidos (1 min → 20s)

### 2. Docker Build Cache

```yaml
cache-from: type=registry,ref=ghcr.io/.../buildcache
cache-to: type=registry,ref=ghcr.io/.../buildcache,mode=max
```

**Beneficio**: Builds 3-5x más rápidos (5 min → 1-2 min)

### 3. Conditional Jobs

```yaml
jobs:
  build-and-push:
    needs: test  # Solo ejecuta si tests pasan
    if: github.event_name == 'push'  # Solo en push, no en PR
```

**Beneficio**: Ahorra minutos de CI cuando tests fallan

### 4. Path Filters

```yaml
on:
  push:
    paths-ignore:
      - '**.md'
      - '.gitignore'
```

**Beneficio**: No ejecuta pipeline en cambios de documentación

## Monitoreo y Debugging

### Ver Logs en Tiempo Real

```bash
# Usando GitHub CLI
gh run watch

# Ver logs de un job específico
gh run view --log

# Lista de runs recientes
gh run list --limit 10
```

### Debugging con SSH (Emergencias)

Agrega este step temporalmente:

```yaml
- name: Setup tmate session
  uses: mxschmitt/action-tmate@v3
  if: failure()  # Solo si el job falla
```

Esto te da acceso SSH al runner para debugging.

## Métricas del Pipeline

<CardGroup cols={2}>
  <Card title="Tiempo Promedio" icon="clock">
    **6 minutos**

    - Tests: 1-2 min
    - Build: 2-3 min
    - Push & Update: 1-2 min
  </Card>
  <Card title="Tasa de Éxito" icon="chart-line">
    **94.5%**

    Basado en últimos 100 runs
  </Card>
  <Card title="Ejecuciones/Día" icon="calendar">
    **~15 runs**

    Promedio entre todos los servicios
  </Card>
  <Card title="Costo Mensual" icon="dollar-sign">
    **\$0 (gratis)**

    GitHub Actions es gratis para repos públicos
  </Card>
</CardGroup>

## Best Practices Implementadas

<AccordionGroup>
  <Accordion title="✅ Jobs Independientes">
    Cada job puede fallar independientemente. Si los tests fallan, no se ejecuta el build.
  </Accordion>
  <Accordion title="✅ Fail Fast">
    El pipeline se detiene al primer error. No desperdicia tiempo en builds que fallarán.
  </Accordion>
  <Accordion title="✅ Immutable Tags">
    Cada build tiene un tag único basado en el SHA del commit. Nunca se sobreescribe.
  </Accordion>
  <Accordion title="✅ Audit Trail">
    Cada despliegue genera un PR con metadata completa. Historial completo en Git.
  </Accordion>
  <Accordion title="✅ Security Scanning">
    Docker Scout escanea vulnerabilidades en cada imagen antes del push.
  </Accordion>
</AccordionGroup>

## Troubleshooting

<AccordionGroup>
  <Accordion title="Error: Docker login failed">
    **Causa**: Token de Docker Hub inválido o expirado

    **Solución**:

    ```bash
    # Generar nuevo token en Docker Hub
    # Actualizar secret DOCKERHUB_TOKEN en GitHub
    ```
  </Accordion>
  <Accordion title="Error: Tests failing">
    **Causa**: Tests no pasan localmente tampoco

    **Solución**:

    ```bash
    # Ejecutar tests localmente primero
    npm test
    npm run test:coverage
    
    # Fix tests antes de push
    ```
  </Accordion>
  <Accordion title="Error: Permission denied updating K8s repo">
    **Causa**: PAT sin permisos suficientes

    **Solución**:

    - Verificar que el PAT tenga scope `repo` y `workflow`
    - Regenerar PAT si es necesario
    - Actualizar secret `K8S_UPDATE_TOKEN`
  </Accordion>
  <Accordion title="Workflow no se ejecuta">
    **Causa**: Cambios solo en archivos ignorados (\*.md)

    **Solución**: Normal. El workflow solo se ejecuta en cambios de código.
  </Accordion>
</AccordionGroup>

## Próximos Pasos

<CardGroup cols={2}>
  <Card title="GitOps Workflow" icon="code-branch" href="/cicd/gitops-workflow">
    Flujo completo de GitOps
  </Card>
  <Card title="CI/CD Overview" icon="rocket" href="/cicd/overview">
    Visión general del pipeline
  </Card>
  <Card title="Monitoreo" icon="chart-line" href="/infrastructure/monitoring">
    Observabilidad del sistema
  </Card>
  <Card title="Infraestructura" icon="server" href="/infrastructure/overview">
    Setup de AWS y Kubernetes
  </Card>
</CardGroup>