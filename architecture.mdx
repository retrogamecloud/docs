---
title: 2.1. Arquitectura del Sistema
description: Visión general de la arquitectura de microservicios cloud-native de Retro
  Game Hub desplegada en AWS EKS, incluyendo decisiones arquitectónicas y justificaciones
  técnicas
icon: file-lines
---

## Visión General de la Arquitectura

Retro Game Hub está construido usando una arquitectura de microservicios cloud-native desplegada en AWS EKS (Kubernetes). La arquitectura sigue principios de escalabilidad, alta disponibilidad y separación de responsabilidades, organizándose en capas claramente definidas.

## Arquitectura de Alto Nivel

```mermaid
graph TD
    subgraph "CAPA DE ENTRADA"
        A[CloudFront CDN<br/>Game Assets & Static Content]
        B[Application Load Balancer<br/>SSL/TLS Termination]
    end

    subgraph "CAPA DE GATEWAY"
        C[GitHub OAuth2 Proxy<br/>Monitoring Authentication]
        G[Kong API Gateway<br/>Routing & Rate Limiting]
    end

    subgraph "CAPA DE OBSERVABILIDAD"
        D[Grafana<br/>Dashboards]
        E[Prometheus<br/>Metrics Collection]
        F[AlertManager<br/>Alerting]
    end

    subgraph "CAPA DE APLICACIÓN - EKS Cluster"
        H[Auth Service<br/>:3001]
        I[Game Catalog Service<br/>:3002]
        J[Score Service<br/>:3003]
        K[Ranking Service<br/>:3004]
        L[User Service<br/>:3005]
        M[Frontend Static<br/>js-dos Emulator]
    end

    subgraph "CAPA DE DATOS"
        N[PostgreSQL RDS<br/>Primary Database]
        O[Redis Cache<br/>Rankings & Sessions]
        P[S3 Bucket<br/>Game Assets & Static Files]
    end

    A --> B
    B --> C
    B --> G
    C --> D
    C --> E
    C --> F
    G --> H
    G --> I
    G --> J
    G --> K
    G --> L
    G --> M
    H --> N
    I --> N
    J --> N
    J --> O
    K --> O
    L --> N
    A -.-> P
    M -.-> P
```

## Diagrama de Componentes (Vista C4)

```mermaid
graph TB
    subgraph "Usuario"
        U[Browser<br/>Cliente Web]
    end
    
    subgraph "AWS Cloud"
        subgraph "CDN & Load Balancer"
            CF[CloudFront CDN]
            ALB[Application Load Balancer]
        end
        
        subgraph "EKS Cluster"
            subgraph "Gateway Layer"
                KONG[Kong API Gateway<br/>Puerto: 80/443]
                OAUTH[OAuth2 Proxy<br/>Puerto: 4180]
            end
            
            subgraph "Frontend"
                FE[Frontend React App<br/>js-dos Emulator<br/>Puerto: 3000]
            end
            
            subgraph "Microservicios"
                AUTH[Auth Service<br/>Node.js/Express<br/>Puerto: 3001]
                CATALOG[Game Catalog Service<br/>Node.js/Express<br/>Puerto: 3002]
                SCORE[Score Service<br/>Node.js/Express<br/>Puerto: 3003]
                RANKING[Ranking Service<br/>Node.js/Express<br/>Puerto: 3004]
                USER[User Service<br/>Node.js/Express<br/>Puerto: 3005]
            end
            
            subgraph "Monitoring"
                PROM[Prometheus<br/>Puerto: 9090]
                GRAF[Grafana<br/>Puerto: 3000]
                ALERT[AlertManager<br/>Puerto: 9093]
            end
        end
        
        subgraph "Capa de Datos"
            PG[(PostgreSQL RDS<br/>Puerto: 5432)]
            REDIS[(Redis Cache<br/>Puerto: 6379)]
            S3[(S3 Bucket<br/>Game Assets)]
        end
    end

    %% Conexiones de Usuario
    U --> CF
    CF --> ALB
    ALB --> KONG
    ALB --> OAUTH
    
    %% Conexiones de Gateway
    KONG --> FE
    KONG --> AUTH
    KONG --> CATALOG
    KONG --> SCORE
    KONG --> RANKING
    KONG --> USER
    
    OAUTH --> GRAF
    OAUTH --> PROM
    OAUTH --> ALERT
    
    %% Conexiones de Frontend
    FE --> S3
    
    %% Conexiones de Microservicios a Bases de Datos
    AUTH --> PG
    CATALOG --> PG
    SCORE --> PG
    SCORE --> REDIS
    RANKING --> REDIS
    USER --> PG
    
    %% Conexiones de Monitoreo
    PROM --> AUTH
    PROM --> CATALOG
    PROM --> SCORE
    PROM --> RANKING
    PROM --> USER
    PROM --> KONG
    ALERT --> PROM
    GRAF --> PROM
    
    %% CDN a S3
    CF -.-> S3

    %% Estilos
    classDef frontend fill:#e1f5fe
    classDef gateway fill:#f3e5f5
    classDef microservice fill:#e8f5e8
    classDef database fill:#fff3e0
    classDef monitoring fill:#fce4ec
    classDef external fill:#f5f5f5
    
    class FE frontend
    class KONG,OAUTH gateway
    class AUTH,CATALOG,SCORE,RANKING,USER microservice
    class PG,REDIS,S3 database
    class PROM,GRAF,ALERT monitoring
    class CF,ALB external
```

## Arquitectura por Capas Detallada

### 1. Capa de Entrada
Esta capa maneja todo el tráfico entrante y la distribución de contenido:

- **CloudFront CDN**: Distribución global de contenido estático y assets de juegos
- **Application Load Balancer**: Terminación SSL/TLS y balanceo de carga
- **Route 53**: Gestión de DNS y enrutamiento de tráfico

### 2. Capa de Gateway
Actúa como punto de entrada único para todas las solicitudes:

- **Kong API Gateway**: Enrutamiento de solicitudes, rate limiting, autenticación de APIs
- **OAuth2 Proxy**: Autenticación para herramientas de monitoreo usando GitHub OAuth

### 3. Capa de Aplicación
Contiene todos los microservicios y el frontend:

#### Frontend
- **React Application**: Interfaz de usuario con integración del emulador js-dos
- **js-dos Emulator**: Ejecuta juegos DOS directamente en el navegador

#### Microservicios
- **Auth Service** (Puerto 3001): Gestión de autenticación y autorización
- **Game Catalog Service** (Puerto 3002): Catálogo y metadata de juegos
- **Score Service** (Puerto 3003): Gestión de puntuaciones y progreso
- **Ranking Service** (Puerto 3004): Cálculo y gestión de rankings
- **User Service** (Puerto 3005): Gestión de perfiles y datos de usuario

### 4. Capa de Datos
Almacenamiento persistente y caché:

- **PostgreSQL RDS**: Base de datos principal para datos transaccionales
- **Redis Cache**: Caché para rankings, sesiones y datos de alta frecuencia
- **S3 Bucket**: Almacenamiento de assets de juegos y contenido estático

### 5. Capa de Observabilidad
Monitoreo y alertas del sistema:

- **Prometheus**: Recolección de métricas de todos los servicios
- **Grafana**: Dashboards y visualización de métricas
- **AlertManager**: Gestión y envío de alertas

## Decisiones Arquitectónicas

### Microservicios vs Monolito
**Decisión**: Arquitectura de microservicios
**Justificación**:
- Escalabilidad independiente por servicio
- Equipos pueden trabajar de forma independiente
- Tolerancia a fallos mejorada
- Flexibilidad tecnológica por servicio

### Kubernetes en AWS EKS
**Decisión**: AWS EKS como plataforma de orquestación
**Justificación**:
- Gestión automática del plano de control
- Integración nativa con servicios AWS
- Escalado automático de nodos
- Soporte enterprise y comunidad activa

### Kong como API Gateway
**Decisión**: Kong Gateway en lugar de AWS API Gateway
**Justificación**:
- Mayor flexibilidad de configuración
- Plugins extensibles para funcionalidades específicas
- Mejor rendimiento para alto volumen de requests
- Portabilidad entre clouds

### PostgreSQL como Base de Datos Principal
**Decisión**: PostgreSQL RDS
**Justificación**:
- ACID compliance para datos críticos
- Soporte robusto para consultas complejas
- Gestión automática de backups y mantenimiento
- Escalado vertical y horizontal disponible

### Redis para Caché y Rankings
**Decisión**: Redis como sistema de caché
**Justificación**:
- Excelente rendimiento para datos en memoria
- Estructuras de datos especializadas para rankings
- Persistencia opcional para datos importantes
- Integración simple con aplicaciones Node.js

## Patrones Arquitectónicos Implementados

### 1. API Gateway Pattern
Kong actúa como punto de entrada único, proporcionando:
- Enrutamiento centralizado
- Autenticación y autorización
- Rate limiting y throttling
- Transformación de requests/responses

### 2. Database per Service
Cada microservicio tiene su propio esquema/namespace en PostgreSQL:
- Aislamiento de datos
- Evolución independiente de esquemas
- Reducción de acoplamiento entre servicios

### 3. Circuit Breaker Pattern
Implementado en las comunicaciones inter-servicios para:
- Prevenir fallos en cascada
- Degradación gradual de funcionalidades
- Recuperación automática

### 4. Event-Driven Architecture
Para comunicación asíncrona entre servicios:
- Eventos de puntuación para actualización de rankings
- Eventos de usuario para sincronización de datos
- Desacoplamiento temporal entre servicios